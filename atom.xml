<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="https://github.com/Straight-GZ/atom.xml" rel="self"/>
  
  <link href="https://github.com/Straight-GZ/"/>
  <updated>2021-03-05T08:37:14.000Z</updated>
  <id>https://github.com/Straight-GZ/</id>
  
  <author>
    <name>耿直</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TS的泛型</title>
    <link href="https://github.com/Straight-GZ/2021/03/05/TS%E6%B3%9B%E5%9E%8B/"/>
    <id>https://github.com/Straight-GZ/2021/03/05/TS%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-03-05T08:37:14.000Z</published>
    <updated>2021-03-05T08:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、泛型有什么用？"><a href="#1、泛型有什么用？" class="headerlink" title="1、泛型有什么用？"></a>1、泛型有什么用？</h5><p>先看一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(x: string): string &#123;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn(1)) &#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果这样写，函数 fn 只能接受 string 类型，如果想要传入别的类型，返回别的类型呢？这样需要使用泛型</p>   <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn&lt;T&gt;(x:T):T&#123;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn(true)) &#x2F;&#x2F; true</span><br><span class="line">console.log(fn(1))   &#x2F;&#x2F; 1</span><br><span class="line">console.log(fn(&#39;1&#39;)) &#x2F;&#x2F; &#39;1&#39;</span><br><span class="line">console.log(fn([1, 2, 3])) &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>T 帮助我们捕获用户传入的类型（比如：number），我们就可以使用这个类型,之后我们再次使用了 T 当做返回值类型。这个函数 fn 就叫做泛型</p><ul><li><p>使用</p><ul><li>传入参数、类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let n &#x3D; identity&lt;string&gt;(&quot;n&quot;);</span><br></pre></td></tr></table></figure><ul><li>类型推论</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let n &#x3D; identity(&quot;n&quot;);</span><br></pre></td></tr></table></figure><h5 id="2、泛型变量"><a href="#2、泛型变量" class="headerlink" title="2、泛型变量"></a>2、泛型变量</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn&lt;T&gt;(x: T[]): T[] &#123;</span><br><span class="line">  console.log(x.length);</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><h5 id="3、泛型接口"><a href="#3、泛型接口" class="headerlink" title="3、泛型接口"></a>3、泛型接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Fn&lt;T&gt; &#123;</span><br><span class="line">   (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn&lt;T&gt;(x: T): T &#123;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let func: Fn&lt;number&gt; &#x3D; fn;</span><br></pre></td></tr></table></figure><h5 id="4、泛型类"><a href="#4、泛型类" class="headerlink" title="4、泛型类"></a>4、泛型类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  class X&lt;T&gt; &#123;</span><br><span class="line">    value: T;</span><br><span class="line">    add: (x: T, y: T) &#x3D;&gt; T;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">let x &#x3D; new X&lt;number&gt;();</span><br><span class="line">x.value &#x3D; 0;</span><br><span class="line">x.add &#x3D; function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p><h5 id="5、泛型约束"><a href="#5、泛型约束" class="headerlink" title="5、泛型约束"></a>5、泛型约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line">function fn&lt;T extends Lengthwise&gt;(n: T): T &#123;</span><br><span class="line">    console.log(n.length);</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(1)   &#x2F;&#x2F;error，必须带有length属性</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;1、泛型有什么用？&quot;&gt;&lt;a href=&quot;#1、泛型有什么用？&quot; class=&quot;headerlink&quot; title=&quot;1、泛型有什么用？&quot;&gt;&lt;/a&gt;1、泛型有什么用？&lt;/h5&gt;&lt;p&gt;先看一个函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function fn(x: string): string &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(fn(1)) &amp;#x2F;&amp;#x2F; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果这样写，函数 fn 只能接受 string 类型，如果想要传入别的类型，返回别的类型呢？这样需要使用泛型&lt;/p&gt;</summary>
    
    
    
    
    <category term="Typescript" scheme="https://github.com/Straight-GZ/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖和函数节流</title>
    <link href="https://github.com/Straight-GZ/2021/03/01/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>https://github.com/Straight-GZ/2021/03/01/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</id>
    <published>2021-03-01T09:25:27.000Z</published>
    <updated>2021-03-01T09:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、函数防抖"><a href="#1、函数防抖" class="headerlink" title="1、函数防抖"></a>1、函数防抖</h5><p>在事件被触发 n 秒后，在执行函数，如果 n 秒内被重新触发，则重新计时</p>   <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> const debounce&#x3D;(fn,delay)&#x3D;&gt;&#123;</span><br><span class="line">  let timer&#x3D;null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let context&#x3D;this  &#x2F;&#x2F;获取debounce执行作用域的this</span><br><span class="line">    &#x2F;&#x2F;如果计时器存在，那么就将计时器取消，新增一个计时器，重新计时</span><br><span class="line">    if(timer)&#123;clearTimeout(timer)&#125;</span><br><span class="line">    timer&#x3D;setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      fn.apply(context,arguments)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const x&#x3D;x(()&#x3D;&gt;&#123;console.log(&#39;1&#39;)&#125;,1000)</span><br><span class="line">x()</span><br><span class="line">x()   &#x2F;&#x2F;延迟时间内多次执行，函数只会执行一次</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/hardcore-bose-kq9gg">代码演示</a></p><h4 id="2、函数节流"><a href="#2、函数节流" class="headerlink" title="2、函数节流"></a>2、函数节流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const context &#x3D; this;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">        fn.apply(context, arguments);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const x&#x3D;throttle()</span><br><span class="line">x()</span><br><span class="line">x()</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/frosty-fermi-cztc1">代码演示</a></p>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;1、函数防抖&quot;&gt;&lt;a href=&quot;#1、函数防抖&quot; class=&quot;headerlink&quot; title=&quot;1、函数防抖&quot;&gt;&lt;/a&gt;1、函数防抖&lt;/h5&gt;&lt;p&gt;在事件被触发 n 秒后，在执行函数，如果 n 秒内被重新触发，则重新计时&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://github.com/Straight-GZ/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BFC是什么？</title>
    <link href="https://github.com/Straight-GZ/2021/02/20/BFC/"/>
    <id>https://github.com/Straight-GZ/2021/02/20/BFC/</id>
    <published>2021-02-20T02:48:53.000Z</published>
    <updated>2021-02-20T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、BFC-概念"><a href="#1、BFC-概念" class="headerlink" title="1、BFC 概念"></a>1、BFC 概念</h3><ul><li>块格式化上下文（Block Formatting Context，BFC），是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</li><li>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<a id="more"></a></li></ul><h3 id="2、触发-BFC"><a href="#2、触发-BFC" class="headerlink" title="2、触发 BFC"></a>2、触发 BFC</h3><p>常见触发 BFC 的方式</p><ul><li>根元素（html）</li><li>浮动元素（元素的 float 不是 none）</li><li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li><li>行内块元素（元素的 display 为 inline-block）</li><li>overflow 计算值(Computed)不为 visible 的块元素</li><li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li><li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li></ul><h3 id="4、BFC-的特性"><a href="#4、BFC-的特性" class="headerlink" title="4、BFC 的特性"></a>4、BFC 的特性</h3><ol><li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列.</li><li>盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li></ol><p>BFC 是一个独立的渲染区域，它规定了内部如何布局，与外部互不干涉</p><h3 id="5、BFC-的应用"><a href="#5、BFC-的应用" class="headerlink" title="5、BFC 的应用"></a>5、BFC 的应用</h3><ol><li><p>避免外边距重叠</p><p>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p></li><li><p>清楚浮动<br>浮动的元素会脱离普通文档流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> .test1&#123;</span><br><span class="line">     border:1px solid red;</span><br><span class="line"> &#125;</span><br><span class="line"> .test2&#123;</span><br><span class="line">     float:left;</span><br><span class="line">     width:100px;</span><br><span class="line">     height:100px;</span><br><span class="line">     border:1px solid black;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;div class&#x3D;test1&gt;</span><br><span class="line">     &lt;div class&#x3D;test2&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/09/ILwB5DpFQ8RzmCr.png" alt="image-20210309124909376"></p><p>这时候只要触发容器<code>test1</code>的 BFC 就可以清除浮动<br><img src="https://i.loli.net/2021/03/09/v3rmNdEZKQfALyi.png" alt="image-20210309125307615"></p></li><li><p>BFC 可以阻止元素被浮动元素覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.test1&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     height:100px;</span><br><span class="line">     border:1px solid red;</span><br><span class="line">     float:left;</span><br><span class="line"> &#125;</span><br><span class="line"> .test2&#123;</span><br><span class="line"> border:1px solid black;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;test1&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;test2&gt;文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/09/C7VMyNGY8c5eRhp.png" alt="image-20210309125831884"><br>此时，只需要触发<code>test2</code>的 BFC 就可以解决</p><p>这种方法也可以实现一侧固定宽度，一侧自适应的两栏布局。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、BFC-概念&quot;&gt;&lt;a href=&quot;#1、BFC-概念&quot; class=&quot;headerlink&quot; title=&quot;1、BFC 概念&quot;&gt;&lt;/a&gt;1、BFC 概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;块格式化上下文（Block Formatting Context，BFC），是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。&lt;/li&gt;
&lt;li&gt;具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="CSS" scheme="https://github.com/Straight-GZ/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex的基本用法</title>
    <link href="https://github.com/Straight-GZ/2021/02/16/Vuex/"/>
    <id>https://github.com/Straight-GZ/2021/02/16/Vuex/</id>
    <published>2021-02-16T06:54:09.000Z</published>
    <updated>2021-02-16T06:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、Vuex-是什么？"><a href="#1、Vuex-是什么？" class="headerlink" title="1、Vuex 是什么？"></a>1、Vuex 是什么？</h5><p>一个专为 Vue.js 应用程序开发的状态管理工具</p><h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><ul><li>解耦：将所有数据相关的逻辑放入 store（也就是 MVC 中的 Model，换了个名字而已）</li><li>数据读写更方便：任何组件不管在哪里，都可以直接读写数据</li><li>控制力更强：组件对数据的读写只能使用 store 提供的 API 进行<a id="more"></a></li></ul><h5 id="3、核心概念"><a href="#3、核心概念" class="headerlink" title="3、核心概念"></a>3、核心概念</h5><p>Vuex 的核心就是仓库 store，这个 store 实例会被注入到所有子组件里面,子组件通过<code>this.$store</code>获取</p><p>主要架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>state</p><p>state 属性保存着全局的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  count: 10   &#x2F;&#x2F;定义状态</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件通过计算属性获取</span><br><span class="line">computed: &#123;</span><br><span class="line">  count() &#123;</span><br><span class="line">    return this.$store.state.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapState：辅助函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">computed: mapState(&#123;</span><br><span class="line">    count: state &#x3D;&gt; state.count,</span><br><span class="line">    &#x2F;&#x2F; 传字符串参数 &#39;count&#39; 等同于 &#96;state &#x3D;&gt; state.count&#96;</span><br><span class="line">    countAlias: &#39;count&#39;,</span><br><span class="line">    &#x2F;&#x2F; 为了能够使用 &#96;this&#96; 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象三点操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  computed: &#123;</span><br><span class="line">    msg() &#123;</span><br><span class="line">      return this.$store.state.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">  ...mapState([&#39;count&#39;, &#39;firstName&#39;, &#39;lastName&#39;])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>Getter</p><p>对状态进行处理的提取出来的公共部分,可以理解为 state 的计算属性，结果会缓存，且只有当它的依赖值发生了改变才会被重新计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">  list: [1, 2, 3, 4, 5]</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">  modifyArr(state) &#123;</span><br><span class="line">    return state.list.filter((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">      return item % 2 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getLength(state, getter) &#123; &#x2F;&#x2F; 方法里面传getter，调用modifyArr来计算长度</span><br><span class="line">    return getter.modifyArr.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>mapGetters:辅助函数,将 store 中的 getter 映射到局部计算属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">&#x2F;&#x2F; 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    &#39;modifyArr&#39;,</span><br><span class="line">    &#39;getLength&#39;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;改名</span><br><span class="line">  computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    x:&#39;modifyArr&#39;,</span><br><span class="line">    y:&#39;getLength&#39;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Mutation</p><ul><li><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变更状态</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(&#39;increment&#39;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;提交额外参数</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state,n) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变更状态</span><br><span class="line">    state.count+&#x3D; n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(&#39;increment&#39;,1)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对象风格的提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: &#39;increment&#39;,</span><br><span class="line">  n: 10</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, obj) &#123;</span><br><span class="line">    state.count +&#x3D; obj.n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapMutations:辅助函数</p><p>官方代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapMutations&#125; from &#39;vuex&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations([</span><br><span class="line">    &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：</span><br><span class="line">    &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;</span><br><span class="line">  ]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Action</p><p>Action 类似于 mutation，不同在于：</p><p>Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   actions: &#123;</span><br><span class="line">  increment (context) &#123; &#x2F;&#x2F;context是和store 实例具有相同方法和属性的对象</span><br><span class="line">    context.commit(&#39;increment&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）</p><p><a href="https://vuex.vuejs.org/zh/guide/actions.html">文档</a></p></li><li><p>Module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const moduleA &#x3D; &#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><p><a href="https://vuex.vuejs.org/zh/guide/modules.html">官方文档</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;1、Vuex-是什么？&quot;&gt;&lt;a href=&quot;#1、Vuex-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、Vuex 是什么？&quot;&gt;&lt;/a&gt;1、Vuex 是什么？&lt;/h5&gt;&lt;p&gt;一个专为 Vue.js 应用程序开发的状态管理工具&lt;/p&gt;
&lt;h5 id=&quot;2、作用&quot;&gt;&lt;a href=&quot;#2、作用&quot; class=&quot;headerlink&quot; title=&quot;2、作用&quot;&gt;&lt;/a&gt;2、作用&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;解耦：将所有数据相关的逻辑放入 store（也就是 MVC 中的 Model，换了个名字而已）&lt;/li&gt;
&lt;li&gt;数据读写更方便：任何组件不管在哪里，都可以直接读写数据&lt;/li&gt;
&lt;li&gt;控制力更强：组件对数据的读写只能使用 store 提供的 API 进行&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router</title>
    <link href="https://github.com/Straight-GZ/2021/02/10/Vue%20router/"/>
    <id>https://github.com/Straight-GZ/2021/02/10/Vue%20router/</id>
    <published>2021-02-10T08:06:54.000Z</published>
    <updated>2021-02-10T08:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、Vue-Router"><a href="#1、Vue-Router" class="headerlink" title="1、Vue Router"></a>1、Vue Router</h5><p>Vue.js 官方的路由管理器。路由就是 SPA（single page application 单页应用）的路径管理器，单页面应用的思路是一个 index.html 里面有一个容器，在用户进行交互的时候，并不会重新加载某个界面，而是只选择把某个视图更新到容器中去显示。</p> <a id="more"></a><h5 id="2、路由模式"><a href="#2、路由模式" class="headerlink" title="2、路由模式"></a>2、路由模式</h5><ul><li><p>hash 模式</p><p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。# 是 url 的一个锚点，记载了网页中的位置，Hash 模式通过锚点值的改变，根据不同的值，渲染指定 DOM 位置的不同数据。<br>hash 模式的原理是 onhashchange 事件(监测 hash 值变化)，可以在 window 对象上监听这个事件。</p></li></ul><ul><li><p>history 模式</p><p>当你使用 history 模式时，URL 就像正常的 url，需要后台配置支持</p></li></ul><h5 id="3、页面跳转"><a href="#3、页面跳转" class="headerlink" title="3、页面跳转"></a>3、页面跳转</h5><ul><li><p>声明式：以标签的形式声明为一个跳转的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;简单用法</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;传递参数</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;url 传值（index.js设置路由）</span><br><span class="line">&#123;</span><br><span class="line">  path:&#39;&#x2F;user&#x2F;:id&#x2F;&#39;, &#x2F;&#x2F;id就是传递的参数</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取参数</span><br><span class="line">$route.params.key</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用name匹配路由，使用query来传递参数</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name:&#39;xxx&#39;,query: &#123; key:value&#125;&#125;&quot; &gt;跳转Query&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;获取参数</span><br><span class="line">this.$route.query.queryId</span><br></pre></td></tr></table></figure><p><strong>param 和 query 的区别</strong></p><ul><li>使用 params 传参只能用 name 来引入路由，即 push 里面只能是 name:’xxx’,不能是 path:’/xxx’,因为 params 只能用 name 来引入路由，如果这里写成了 path，接收参数页面会是 undefined。</li><li>query name 和 path 都支持。query，url 会加上参数信息，而 param url 并不会携带参数信息。</li></ul></li></ul><ul><li><p>编程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不带参数</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 带参数 params</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;,params:&#123;key:value&#125;&#125;)</span><br><span class="line">&#x2F;&#x2F;query</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;,query:&#123;key:value&#125;&#125;)</span><br><span class="line"></span><br><span class="line">this.$router.go(-1)&#x2F;&#x2F;跳转到上一次浏览的页面</span><br><span class="line">this.$router.replace(&#39;&#x2F;menu&#39;)&#x2F;&#x2F;指定跳转的地址</span><br><span class="line">this.$router.replace(&#123;name:&#39;menuLink&#39;&#125;)&#x2F;&#x2F;指定跳转路由的名字下</span><br></pre></td></tr></table></figure><p><strong>push 和 replace 的区别：</strong></p><ul><li>使用 push 方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。也就是说是支持后退的。</li></ul><ul><li>使用 replace 方法不会向 history 添加新记录，而是替换掉当前的 history 记录，即当 replace 跳转到的网页后，’后退’ 按钮不能查看之前的页面。</li></ul></li></ul><h5 id="4、导航守卫"><a href="#4、导航守卫" class="headerlink" title="4、导航守卫"></a>4、导航守卫</h5><ol><li><p>全局前置守卫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数</p></li></ol><ul><li><p>to 即将要进入的目标 路由对象</p></li><li><p>from 当前导航正要离开的路由</p></li><li><p>next 要执行的操作</p><ul><li>next(): 进行管道中的下一个钩子（放行）。</li><li>next(false): 中断当前的导航。</li><li>next(‘/‘) 或者 next({ path: ‘/‘ }):跳转到一个不同的地址。</li><li>next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li></ul></li></ul><ol start="2"><li><p>全局解析守卫</p><p> router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p></li><li><p>全局后置钩子</p><p> 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>路由独享的守卫<br> 在路由配置上直接定义 beforeEnter 守卫：<br> 与全局前置守卫的方法参数是一样的。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>组件内的守卫</p><ul><li>beforeRouteEnter</li></ul><ul><li>beforeRouteUpdate</li><li>beforeRouteLeave</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  const Foo &#x3D; &#123;</span><br><span class="line">  template: &#96;...&#96;,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;</span><br><span class="line">    &#x2F;&#x2F; 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，</span><br><span class="line">    &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 导航离开该组件的对应路由时调用</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beforeRouteEnter 守卫 不能 访问 this,可以通过传一个回调给 next 来访问组件实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 &#96;vm&#96; 访问组件实例</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的导航解析流程</p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">官方文档</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;1、Vue-Router&quot;&gt;&lt;a href=&quot;#1、Vue-Router&quot; class=&quot;headerlink&quot; title=&quot;1、Vue Router&quot;&gt;&lt;/a&gt;1、Vue Router&lt;/h5&gt;&lt;p&gt;Vue.js 官方的路由管理器。路由就是 SPA（single page application 单页应用）的路径管理器，单页面应用的思路是一个 index.html 里面有一个容器，在用户进行交互的时候，并不会重新加载某个界面，而是只选择把某个视图更新到容器中去显示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>图床项目</title>
    <link href="https://github.com/Straight-GZ/2021/01/16/%E5%9B%BE%E5%BA%8A%E9%A1%B9%E7%9B%AE/"/>
    <id>https://github.com/Straight-GZ/2021/01/16/%E5%9B%BE%E5%BA%8A%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-01-16T15:06:09.000Z</published>
    <updated>2021-01-16T15:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、Suspense-和-lazy"><a href="#1、Suspense-和-lazy" class="headerlink" title="1、Suspense 和 lazy"></a>1、Suspense 和 lazy</h5><ul><li>Suspense</li></ul><p>React 16.6 新增了 <Suspense> 组件，让你可以“等待”目标代码加载，并且可以直接指定一个加载的界面（像是个 spinner），让它在用户等待的时候显示<br><a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#gatsby-focus-wrapper">官方文档</a></Suspense></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback &#x3D; &#123;&lt;Loading&#x2F;&gt;&#125;&gt;      &#x2F;&#x2F;等待加载时显示 Loading组件</span><br><span class="line">&lt;&#x2F;Suspense&gt;</span><br></pre></td></tr></table></figure> <a id="more"></a><ul><li>React.lazy</li></ul><p>动态引入组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用前</span><br><span class="line">import Home from &#39;.&#x2F;pages&#x2F;Home&#39;</span><br><span class="line">import History from &#39;.&#x2F;pages&#x2F;History&#39;</span><br><span class="line">import About from &#39;.&#x2F;pages&#x2F;About&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用后</span><br><span class="line">import &#123;lazy&#125; from &#39;react&#39;</span><br><span class="line">const Home &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;Home&#39;))</span><br><span class="line">const History &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;History&#39;))</span><br><span class="line">const About &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;About&#39;))</span><br></pre></td></tr></table></figure><p>React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。</p><p>然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优</p><ul><li>完整代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Suspense, lazy&#125; from &#39;react&#39;</span><br><span class="line">import &#39;.&#x2F;App.css&#39;</span><br><span class="line">import Header from &#39;.&#x2F;components&#x2F;Header&#39;</span><br><span class="line">import Footer from &#39;.&#x2F;components&#x2F;Footer&#39;</span><br><span class="line">import &#123;Switch, Route&#125; from &#39;react-router-dom&#39;</span><br><span class="line">import Loading from &#39;.&#x2F;components&#x2F;Loading&#39;</span><br><span class="line">import Login from &#39;.&#x2F;pages&#x2F;Login&#39;</span><br><span class="line">import Register from &#39;.&#x2F;pages&#x2F;Register&#39;</span><br><span class="line">&#x2F;&#x2F; import Home from &#39;.&#x2F;pages&#x2F;Home&#39;</span><br><span class="line">&#x2F;&#x2F; import History from &#39;.&#x2F;pages&#x2F;History&#39;</span><br><span class="line">&#x2F;&#x2F; import About from &#39;.&#x2F;pages&#x2F;About&#39;</span><br><span class="line">const Home &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;Home&#39;))</span><br><span class="line">const History &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;History&#39;))</span><br><span class="line">const About &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;pages&#x2F;About&#39;))</span><br><span class="line">function App() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;&gt;</span><br><span class="line">&lt;Header&#x2F;&gt;</span><br><span class="line">&lt;main&gt;</span><br><span class="line">&lt;Suspense fallback &#x3D; &#123;&lt;Loading&#x2F;&gt;&#125;&gt;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">&lt;Route path &#x3D; &quot;&#x2F;&quot; exact component &#x3D; &#123;Home&#125;&#x2F;&gt;</span><br><span class="line">&lt;Route path &#x3D; &quot;&#x2F;history&quot; component &#x3D; &#123;History&#125;&#x2F;&gt;</span><br><span class="line">&lt;Route path &#x3D; &quot;&#x2F;about&quot; component &#x3D; &#123;About&#125;&#x2F;&gt;</span><br><span class="line">&lt;Route path &#x3D; &quot;&#x2F;Login&quot; component &#x3D; &#123;Login&#125;&#x2F;&gt;</span><br><span class="line">&lt;Route path &#x3D; &quot;&#x2F;Register&quot; component &#x3D; &#123;Register&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Switch&gt;</span><br><span class="line">&lt;&#x2F;Suspense&gt;</span><br><span class="line">&lt;&#x2F;main&gt;</span><br><span class="line">&lt;Footer&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">export default App</span><br></pre></td></tr></table></figure><h3 id="2、mobx"><a href="#2、mobx" class="headerlink" title="2、mobx"></a>2、mobx</h3><ul><li><p>@observable 被观察者</p><ul><li>类似 Vuex 的 state，声明需要的状态</li><li>被观察者可以是：JS 基本数据类型、引用类型、普通对象、类实例、数组和映射</li></ul></li></ul><ul><li><p>action 动作</p><p>用来更改被观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;observable, action, makeObservable&#125; from &#39;mobx&#39;</span><br><span class="line">import &#123;Auth&#125; from &#39;..&#x2F;models&#39;</span><br><span class="line"></span><br><span class="line">class UserStore &#123;</span><br><span class="line">    @observable currentUser &#x3D; null</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        makeObservable(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @action pullUser() &#123;</span><br><span class="line">        this.currentUser &#x3D; Auth.getCurrentUser()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @action resetUser() &#123;</span><br><span class="line">        this.currentUser &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new UserStore()</span><br></pre></td></tr></table></figure></li><li><p>observer</p><p>可以将 React 组件转换为可响应 MobX 的组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123;observer&#125; from &#39;mobx-react&#39;</span><br><span class="line">import Uploader from &#39;..&#x2F;components&#x2F;Uploader&#39;</span><br><span class="line">import Tips from &#39;..&#x2F;components&#x2F;Tips&#39;</span><br><span class="line">const Home &#x3D; observer(() &#x3D;&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;Tips&gt;请先登录!!&lt;&#x2F;Tips&gt;</span><br><span class="line">            &lt;Uploader&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure><p>完整代码见<a href="https://github.com/Straight-GZ/epic/tree/master/src/stores">Github</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;1、Suspense-和-lazy&quot;&gt;&lt;a href=&quot;#1、Suspense-和-lazy&quot; class=&quot;headerlink&quot; title=&quot;1、Suspense 和 lazy&quot;&gt;&lt;/a&gt;1、Suspense 和 lazy&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Suspense&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;React 16.6 新增了 &lt;Suspense&gt; 组件，让你可以“等待”目标代码加载，并且可以直接指定一个加载的界面（像是个 spinner），让它在用户等待的时候显示&lt;br&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#gatsby-focus-wrapper&quot;&gt;官方文档&lt;/a&gt;&lt;/Suspense&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Suspense fallback &amp;#x3D; &amp;#123;&amp;lt;Loading&amp;#x2F;&amp;gt;&amp;#125;&amp;gt;      &amp;#x2F;&amp;#x2F;等待加载时显示 Loading组件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;Suspense&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://github.com/Straight-GZ/tags/React/"/>
    
    <category term="mobx" scheme="https://github.com/Straight-GZ/tags/mobx/"/>
    
    <category term="项目" scheme="https://github.com/Straight-GZ/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>番茄记账React版</title>
    <link href="https://github.com/Straight-GZ/2021/01/06/%E8%AE%B0%E8%B4%A6%E9%A1%B9%E7%9B%AEReact%E7%89%88/"/>
    <id>https://github.com/Straight-GZ/2021/01/06/%E8%AE%B0%E8%B4%A6%E9%A1%B9%E7%9B%AEReact%E7%89%88/</id>
    <published>2021-01-06T06:23:20.000Z</published>
    <updated>2021-01-06T06:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、create-react-app"><a href="#一、create-react-app" class="headerlink" title="一、create-react-app"></a>一、create-react-app</h3><ol><li><p>创建项目</p><ul><li>新建项目目录</li><li>create-react-app . –template typescript (在当前目录创建项目，支持 TS)</li><li>yarn start</li></ul></li><li><p>CSS normalize <a href="https://create-react-app.dev/docs/adding-css-reset">文档</a></p><ul><li><code>@import-normalize; </code></li><li>作用是让不同浏览器上的默认样式相近</li><li>css reset 重置默认样式</li></ul></li><li><p>支持 sass<a href="https://create-react-app.dev/docs/adding-typescript#installation">文档</a></p><ul><li><ol><li>node-sass 下载速度慢，本地编译慢，使用 dart-sass 代替，但 React 不支持 dart-sass</li></ol></li><li><code>yarn add node-sass@npm:dart-sass</code>:使用 dart-sass 代替 node-sass <a href="https://github.com/facebook/create-react-app/issues/5282">github</a></li><li>或者在 package.json 配置，修改 dependencies 配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;node-sass&quot;: &quot;npm:dart-sass&quot;, &quot;dart-sass&quot;: &quot;^1.19.0&quot;</span><br></pre></td></tr></table></figure></li><li>npm6.9 新功能 package alias</li></ul><a id="more"></a></li><li><p>绝对引用 <a href="https://create-react-app.dev/docs/importing-a-component/#absolute-imports">Importing a Component</a></p><ul><li>配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tsconfig.json</span><br><span class="line">&quot;compilerOptions&quot;: &#123;&quot;baseUrl&quot;: &quot;src&quot;&#125;,</span><br><span class="line">&quot;include&quot;: [&quot;src&quot;]</span><br></pre></td></tr></table></figure></li><li>使用：<code>import Button from &#39;components/Button&#39;;</code></li></ul></li></ol><h3 id="二、-styled-components"><a href="#二、-styled-components" class="headerlink" title="二、 styled-components"></a>二、 styled-components</h3><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add styled-components</span><br><span class="line">yarn add --dev @types&#x2F;styled-components</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Button&#x3D;styled.button&#96;</span><br><span class="line">    color:red</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure></li><li><p>插件</p><p>webstorm:styled-components<br>vscode:vscode-styled-components</p></li></ul><h3 id="三、React-Router"><a href="#三、React-Router" class="headerlink" title="三、React-Router"></a>三、React-Router</h3><ul><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom</span><br><span class="line">yarn add @types&#x2F;react-router-dom</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter as Router, Switch, Route, Redirect&#125; from &quot;react-router-dom&quot;;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li>路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  function App() &#123;</span><br><span class="line">      return (</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Redirect exact from &#x3D; &quot;&#x2F;&quot; to &#x3D; &quot;&#x2F;  money&quot;&#x2F;&gt;  &#x2F;&#x2F;重定向</span><br><span class="line">            &lt;Route exact path &#x3D; &quot;&#x2F;tags&quot;&gt;</span><br><span class="line">                &lt;Tags&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Route&gt;</span><br><span class="line">            &lt;Route exact path &#x3D; &quot;&#x2F;tags&#x2F;:id&quot;&gt;</span><br><span class="line">                &lt;Tag&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Route&gt;</span><br><span class="line">            &lt;Route exact path &#x3D; &quot;&#x2F;money&quot;&gt;</span><br><span class="line">                &lt;Money&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Route&gt;</span><br><span class="line">            &lt;Route exact path &#x3D; &quot;&#x2F;statistics&quot;&gt;</span><br><span class="line">                &lt;Statistics&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Route&gt;</span><br><span class="line">            &lt;Route exact path &#x3D; &quot;*&quot;&gt;  &#x2F;&#x2F;除了上面路径之外的404页面</span><br><span class="line">                &lt;NoMatch&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Route&gt;</span><br><span class="line">        &lt;&#x2F;Switch&gt;</span><br><span class="line">      &lt;&#x2F;Router&gt;</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Link 和 传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;tags.tsx</span><br><span class="line">import &#123;Link&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">...</span><br><span class="line"> &lt;Link to &#x3D; &#123;&#39;&#x2F;tags&#x2F;&#39; + tag.id&#125;&gt;    &#x2F;&#x2F;通过url传递参数</span><br><span class="line">          &lt;span&gt;&#123;tag.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;Icon name &#x3D; &#39;right&#39;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Link&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;tag.tsx</span><br><span class="line">import &#123;useHistory, useParams&#125; from &#39;react-router-dom&#39;;</span><br><span class="line">...</span><br><span class="line">let &#123;id: idString&#125; &#x3D; useParams&lt;Params&gt;();   &#x2F;&#x2F;通过useParams拿到</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>useHistory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const history &#x3D; useHistory();</span><br><span class="line">const onClickBack &#x3D; () &#x3D;&gt; &#123;history.goBack();&#125;;    &#x2F;&#x2F;goBack 返回上一级</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>replace：替换历史堆栈上的当前条目</li><li>go:按条目移动历史堆栈中</li><li>goBack:相当于 go(-1)</li><li>goForward:相当于 go(1)</li></ul></li></ul></li><li><p>NavLink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &lt;NavLink to&#x3D;&quot;&#x2F;&quot; activeClassName&#x3D;&quot;selected&quot;&gt; &#x2F;&#x2F;被选中会有对应的class</span><br><span class="line">&lt;&#x2F;NavLink&gt;</span><br></pre></td></tr></table></figure><h3 id="引入-svg"><a href="#引入-svg" class="headerlink" title="引入 svg"></a>引入 svg</h3></li></ul><ul><li><code>yarn eject</code>拿到 webpack 配置</li></ul><ul><li><p>安装<code>svg-sprite-loader</code> <code>svgo-loader</code></p></li><li><p>配置<br><img src="https://ftp.bmp.ovh/imgs/2021/03/44d801cafa948ab4.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: &#x2F;\.svg$&#x2F;,</span><br><span class="line">use: [</span><br><span class="line">&#123;loader: &#39;svg-sprite-loader&#39;, options: &#123;&#125;&#125;,</span><br><span class="line">&#123;</span><br><span class="line">loader: &#39;svgo-loader&#39;, options: &#123;</span><br><span class="line">plugins: [</span><br><span class="line">&#123;removeAttrs: &#123;attrs: &#39;fill&#39;&#125;&#125;,     &#x2F;&#x2F;删除fill属性(颜色)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>tree shaking</strong> 导入未使用默认会被删除，这就导致 svg 引入之后需要使用才能显示在页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import x from &#39;icons&#x2F;chart.svg&#39;</span><br><span class="line">&#x2F;&#x2F;console.log(x) 不加这行 icon不显示   或者使用 require(&#39;icons&#x2F;chart&#39;)</span><br><span class="line">&lt;svg&gt;</span><br><span class="line">    &lt;use xlinkHerf&#x3D;&#39;#chart&#39;&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>封装 Icon 组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const importAll &#x3D; (requireContext: __WebpackModuleApi.RequireContext) &#x3D;&gt; requireContext.keys().forEach(requireContext);</span><br><span class="line">try &#123; importAll(require.context(&#39;icons&#39;, true, &#x2F;\.svg$&#x2F;));&#125; catch (error) &#123; console.log(error);&#125;        &#x2F;&#x2F;引入整个icons文件夹，避免一个一个引入</span><br><span class="line">type Props &#x3D; &#123;</span><br><span class="line">name?: string</span><br><span class="line">&#125; &amp; React.SVGAttributes&lt;SVGElement&gt;</span><br><span class="line">const Icon &#x3D; (props: Props) &#x3D;&gt; &#123;</span><br><span class="line">const &#123;name, children, className, ...rest&#125; &#x3D; props;</span><br><span class="line">return (</span><br><span class="line">    &lt;svg className &#x3D; &#123;cs(&#39;icon&#39;, className)&#125; &#123;...rest&#125;&gt;</span><br><span class="line">    &#123;props.name &amp;&amp; &lt;use xlinkHref &#x3D; &#123;&#39;#&#39; + props.name&#125;&#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;svg&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Icon&#125;;</span><br></pre></td></tr></table></figure><p><code>__WebpackModuleApi</code> 报错 google 搜索 <code>yarn add @types/webpack-env</code>即解决</p></li><li><p>icon 的 onClick</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Props &#x3D; &#123;</span><br><span class="line">name?: string</span><br><span class="line">&#125; &amp; React.SVGAttributes&lt;SVGElement&gt;&#x2F;&#x2F;类型继承SVG所有属性</span><br><span class="line">const Icon &#x3D; (props: Props) &#x3D;&gt; &#123;</span><br><span class="line">const &#123;name, children, className, ...rest&#125; &#x3D; props;</span><br><span class="line">return (</span><br><span class="line">    &#x2F;&#x2F;将外部传入的className和内部的放在一起</span><br><span class="line">    &lt;svg className &#x3D; &#123;&#96;icon $&#123;className&#125;&#96;&#125; &#123;...rest&#125;&gt;</span><br><span class="line">    &#123;props.name &amp;&amp; &lt;use xlinkHref &#x3D; &#123;&#39;#&#39; + props.name&#125;&#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;svg&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;Icon&#125;;</span><br></pre></td></tr></table></figure><p>但是，如果此时外部没有传入 className 属性，当前位置就会变成<code>undefined</code>，解决方法是可以用判断语句，或 classNames 库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用判断</span><br><span class="line">&lt;svg className &#x3D; &#123;&#96;icon $&#123;className ? className : &#39;&#39;&#125;&#96;&#125; &#123;...rest&#125;&gt;</span><br><span class="line">  &#123;props.name &amp;&amp; &lt;use xlinkHref &#x3D; &#123;&#39;#&#39; + props.name&#125;&#x2F;&gt;&#125;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;classnames</span><br><span class="line">  import cs from &quot;classnames&quot;;</span><br><span class="line">  ...</span><br><span class="line">&lt;svg className&#x3D;&#123;cs(&quot;icon&quot;, className)&#125; &#123;...rest&#125;&gt;</span><br><span class="line">  &#123;props.name &amp;&amp; &lt;use xlinkHref&#x3D;&#123;&quot;#&quot; + props.name&#125; &#x2F;&gt;&#125;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h3><p>  使用useState等 返回数据读写接口 就是自定义hook</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;useState&#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const useTags &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">const [tags, setTags] &#x3D; useState&lt;string[]&gt;([&#39;衣&#39;, &#39;食&#39;, &#39;住&#39;, &#39;行&#39;]);</span><br><span class="line">return &#123;tags, setTags&#125;;&#x2F;&#x2F;不return数组 避免ts报错</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;useTags&#125;;</span><br></pre></td></tr></table></figure></code></pre><p>完整代码见 <a href="https://gitee.com/gengzhii/morney-r/tree/master/src/hooks">Gitee</a></p></li></ul><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><ul><li><p>受控模式<br><strong>受控模式</strong> 由 React 监控数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const NoteSection:React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">const [note,setNote]&#x3D;useState&lt;string&gt;(&#39;&#39;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;Wrapper&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;span&gt;备注&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;input type &#x3D; &quot;text&quot; placeholder &#x3D; &#39;在这里输入备注&#39;</span><br><span class="line">          value&#x3D;&#123;note&#125;</span><br><span class="line">          onChange&#x3D;&#123;(e)&#x3D;&gt;setNote(e.target.value)&#125;&#x2F;&#x2F;调用setNote才会更新数据</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;label&gt;</span><br><span class="line">    &lt;&#x2F;Wrapper&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>非受控组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const NoteSection: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">const [note, setNote] &#x3D; useState&lt;string&gt;(&#39;&#39;);</span><br><span class="line">const refInput &#x3D; useRef&lt;htmlinputelement&gt;(null);</span><br><span class="line">const x &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    if (refInput.current) &#123;</span><br><span class="line">      setNote(refInput.current.value); &#x2F;&#x2F;通过ref拿到当前数据</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  console.log(note);</span><br><span class="line">  return (</span><br><span class="line">        &lt;wrapper&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                &lt;span&gt;备注&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;input type &#x3D; &quot;text&quot; placeholder &#x3D; &#39;在这里输入备注&#39;</span><br><span class="line">                ref &#x3D; &#123;refInput&#125;</span><br><span class="line">                defaultValue &#x3D; &#123;note&#125;     &#x2F;&#x2F; 不同于 value</span><br><span class="line">                onBlur &#x3D; &#123;x&#125; &#x2F;&#x2F;如果监听事件，React无法获取数据变化</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;&#x2F;wrapper&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://zenozeng.github.io/fonts.css/">跨平台中文字体解决方案</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、create-react-app&quot;&gt;&lt;a href=&quot;#一、create-react-app&quot; class=&quot;headerlink&quot; title=&quot;一、create-react-app&quot;&gt;&lt;/a&gt;一、create-react-app&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建项目目录&lt;/li&gt;
&lt;li&gt;create-react-app . –template typescript (在当前目录创建项目，支持 TS)&lt;/li&gt;
&lt;li&gt;yarn start&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CSS normalize &lt;a href=&quot;https://create-react-app.dev/docs/adding-css-reset&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@import-normalize; &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;作用是让不同浏览器上的默认样式相近&lt;/li&gt;
&lt;li&gt;css reset 重置默认样式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 sass&lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript#installation&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;node-sass 下载速度慢，本地编译慢，使用 dart-sass 代替，但 React 不支持 dart-sass&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yarn add node-sass@npm:dart-sass&lt;/code&gt;:使用 dart-sass 代替 node-sass &lt;a href=&quot;https://github.com/facebook/create-react-app/issues/5282&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;或者在 package.json 配置，修改 dependencies 配置&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;node-sass&amp;quot;: &amp;quot;npm:dart-sass&amp;quot;, &amp;quot;dart-sass&amp;quot;: &amp;quot;^1.19.0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;npm6.9 新功能 package alias&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://github.com/Straight-GZ/tags/React/"/>
    
    <category term="项目" scheme="https://github.com/Straight-GZ/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>番茄记账Vue版</title>
    <link href="https://github.com/Straight-GZ/2020/12/25/%E7%95%AA%E8%8C%84%E8%AE%B0%E8%B4%A6Vue%E7%89%88/"/>
    <id>https://github.com/Straight-GZ/2020/12/25/%E7%95%AA%E8%8C%84%E8%AE%B0%E8%B4%A6Vue%E7%89%88/</id>
    <published>2020-12-24T17:11:58.000Z</published>
    <updated>2020-12-24T17:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vue-组件三种方式（单文件组件）"><a href="#Vue-组件三种方式（单文件组件）" class="headerlink" title="Vue 组件三种方式（单文件组件）"></a>Vue 组件三种方式（单文件组件）</h4><ol><li><p>用 JS 对象</p><p><code>export default &#123;data,props,methods,created,...&#125;</code></p></li><li><p>用 TS 类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> 组件名 <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  xxx: string = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">  @prop(<span class="built_in">Number</span>) xxx: number | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 JS 类 (和 TS 类似)</p><p><code>export default class 组件名 extends Vue&#123;xxx=&#39;hi&#39;&#125;</code></p></li><li><p>vue-property-decorator</p><p>更好的支持 TS</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import &#123;Component, Prop&#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;Button, FormItem&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class FormItem extends Vue &#123;</span><br><span class="line">  @Prop(&#123;default: &#39;&#39;&#125;) readonly value!: string; &#x2F;&#x2F;prop</span><br><span class="line">  @Prop() options?: EChartsOption;</span><br><span class="line">  ...</span><br><span class="line">  get tags() &#123;    &#x2F;&#x2F;计算属性 computed</span><br><span class="line">    return this.$store.state.tagList;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  @Watch(&#39;options&#39;)   &#x2F;&#x2F;watch</span><br><span class="line">  onOptionsChange(newValue: EChartsOption) &#123;</span><br><span class="line">    this.chart &amp;&amp; this.chart.setOption(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搜集组件的数据"><a href="#搜集组件的数据" class="headerlink" title="搜集组件的数据"></a>搜集组件的数据</h4></li></ol><p>子组件触发事件,将数据发送到父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;update:value&quot;</span>, <span class="built_in">this</span>.selectedTags);</span><br></pre></td></tr></table></figure><p>默认数据可以是外部传入的 Prop，这样可以使用.sync 语法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tags</span> <span class="attr">:data-source.sync</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">:value.sync</span>=<span class="string">&quot;record.tags&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4><h4 id="数据迁移-1"><a href="#数据迁移-1" class="headerlink" title="数据迁移"></a>数据迁移</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前版本号</span></span><br><span class="line"><span class="keyword">const</span> version = <span class="built_in">window</span>.localStorage.getItem(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前数据</span></span><br><span class="line"><span class="keyword">const</span> recordList: Record[] = <span class="built_in">JSON</span>.parse(</span><br><span class="line">  <span class="built_in">window</span>.localStorage.getItem(recordList)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;version&quot;</span> === <span class="string">&quot;0.0.1&quot;</span>) &#123;</span><br><span class="line">  recordList.forEach(<span class="function">(<span class="params">record</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//遍历数据</span></span><br><span class="line">    record.createTime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//将每个数据增加时间</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//保存数据</span></span><br><span class="line">  <span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;recordList&quot;</span>, <span class="built_in">JSON</span>.stringfy(recordList));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;version&quot;</span> === <span class="string">&quot;0.0.2&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">//迁移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置当前版本号</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;0.0.3&quot;</span>);</span><br></pre></td></tr></table></figure><p>迁移数据只需要将版本一个版本一个版本的向上迁移</p><h4 id="定义-TS-类型"><a href="#定义-TS-类型" class="headerlink" title="定义 TS 类型"></a>定义 TS 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordItem = &#123;</span><br><span class="line">  tags: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  notes: <span class="built_in">string</span>;</span><br><span class="line">  amount: <span class="built_in">string</span>;</span><br><span class="line">  createdTime?: <span class="built_in">Date</span>; <span class="comment">// ?表示有也可能没有</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以将内容放在根目录独立文件中，全局定义，文件名以<code>.d.ts</code>结尾，<code>cunstorm.d.ts</code>,当前文件夹内容都可以使用</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>Model(模型):管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令</p><p>View(视图):管理作为位图展示到屏幕上的图形和文字输出；</p><p>Controller(控制器)：翻译用户的输入并依照用户的输入操作模型和视图</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Vuex from &#39;vuex&#39;;</span><br><span class="line">import clone from &#39;@&#x2F;lib&#x2F;clone&#39;;</span><br><span class="line">import createId from &#39;@&#x2F;lib&#x2F;createId&#39;;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">&#x2F;&#x2F;存储数据  使用this.$store.state.recordList获取数据</span><br><span class="line">  state: &#123;</span><br><span class="line">    recordList: [] as RecordItem[],</span><br><span class="line">    createTagMessage: &#39;&#39;,</span><br><span class="line">    tagList: [] as Tag[],</span><br><span class="line">    currentTag: undefined,</span><br><span class="line">  &#125; as RootStore,</span><br><span class="line">&#x2F;&#x2F;对数据的读写  没有返回值  使用this.$store.commit(&#39;fetchTags&#39;,参数)</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setCurrentTag(state, id: string) &#123;</span><br><span class="line">      state.currentTag &#x3D; state.tagList.filter(d &#x3D;&gt; d.id &#x3D;&#x3D;&#x3D; id)[0];</span><br><span class="line">    &#125;,</span><br><span class="line">    fetchTags(state) &#123;&#125;,</span><br><span class="line">    createTag(state, name: string) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeTag(state, id: string) &#123;&#125;,</span><br><span class="line">    saveTags(state) &#123;&#125;,</span><br><span class="line">    updateTag(state, object: &#123; id: string; name: string &#125;) &#123;&#125;,</span><br><span class="line">    fetchRecords(state) &#123;&#125;,</span><br><span class="line">    createRecord(state, record: RecordItem) &#123;&#125;,</span><br><span class="line">    saveRecord(state) &#123;</span><br><span class="line">      window.localStorage.setItem(&#39;recordList&#39;, JSON.stringify(state.recordList));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure><h4 id="使用多个-class"><a href="#使用多个-class" class="headerlink" title="使用多个:class"></a>使用多个<code>:class</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;li :class&#x3D;&quot;value&#x3D;&#x3D;&#x3D;&#39;-&#39; &amp;&amp; &#39;selected&#39;&#125;&quot;  &#x2F;&#x2F;类名加引号 @click&#x3D;&quot;selectType(&#39;-&#39;)&quot;&gt;支出&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;li :class&#x3D;&quot;&#123;[classPrefix+&#39;-item&#39;]:classPrefix,&#39;selected&#39;:value&#x3D;&#x3D;&#x3D;&#39;-&#39;&#125;&quot; @click&#x3D;&quot;selectType(&#39;-&#39;)&quot;&gt;支出&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;如果存在classPrefix 就存在前面的类名  如果类名存在变量，使用[]</span><br><span class="line">[classPrefix+&#39;-item&#39;]:classPrefix,</span><br><span class="line">&#39;selected&#39;:value&#x3D;&#x3D;&#x3D;&#39;-&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Vue-组件三种方式（单文件组件）&quot;&gt;&lt;a href=&quot;#Vue-组件三种方式（单文件组件）&quot; class=&quot;headerlink&quot; title=&quot;Vue 组件三种方式（单文件组件）&quot;&gt;&lt;/a&gt;Vue 组件三种方式（单文件组件）&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用 JS 对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export default &amp;#123;data,props,methods,created,...&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 TS 类&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 组件名 &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vue&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  xxx: string = &lt;span class=&quot;string&quot;&gt;&amp;quot;hi&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @prop(&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;) xxx: number | &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 JS 类 (和 TS 类似)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export default class 组件名 extends Vue&amp;#123;xxx=&amp;#39;hi&amp;#39;&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vue-property-decorator&lt;/p&gt;
&lt;p&gt;更好的支持 TS&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
    <category term="项目" scheme="https://github.com/Straight-GZ/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM</title>
    <link href="https://github.com/Straight-GZ/2020/12/14/%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://github.com/Straight-GZ/2020/12/14/%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2020-12-14T06:45:01.000Z</published>
    <updated>2020-12-14T06:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、虚拟-DOM"><a href="#一、虚拟-DOM" class="headerlink" title="一、虚拟 DOM"></a>一、虚拟 DOM</h2><h4 id="1、虚拟-DOM-是什么？"><a href="#1、虚拟-DOM-是什么？" class="headerlink" title="1、虚拟 DOM 是什么？"></a>1、虚拟 DOM 是什么？</h4><p>一个能代表 DOM 树的对象，通常含有标签名、标签上的属性，事件监听以及其他属性</p><a id="more"></a><h4 id="2、虚拟-DOM-的优点"><a href="#2、虚拟-DOM-的优点" class="headerlink" title="2、虚拟 DOM 的优点"></a>2、虚拟 DOM 的优点</h4><ol><li>减少 DOM 操作</li></ol><ul><li>虚拟 DOM 可以将多次 DOM 操作合并成一次操作。比如添加 1000 个节点，DOM 是一个一个操作，虚拟 DOM 可以减少 DOM 操作次数</li><li>虚拟 DOM 借助 DOM diff 可以省掉多余操作。比如添加 1000 个节点，只有 10 个是新增的。虚拟 DOM 可以减少操作范围</li></ul><ol start="2"><li>跨平台</li></ol><ul><li>虚拟 DOM 是一个对象，不仅可以变成 DOM 还可以变成小程序，ios 应用，本质上是一个 JS 对象</li></ul><h4 id="3、虚拟-DOM-的缺点"><a href="#3、虚拟-DOM-的缺点" class="headerlink" title="3、虚拟 DOM 的缺点"></a>3、虚拟 DOM 的缺点</h4><p>需要额外的创建函数，比如<code>createElement</code>，或<code>h</code>,可以通过 JSX 和 XML 简化，但严重依赖打包工具</p><h2 id="二、DOM-diff"><a href="#二、DOM-diff" class="headerlink" title="二、DOM diff"></a>二、DOM diff</h2><p>DOM diff 是虚拟 DOM 的对比算法</p><h4 id="1、DOM-diff-的优点"><a href="#1、DOM-diff-的优点" class="headerlink" title="1、DOM diff 的优点"></a>1、DOM diff 的优点</h4><ul><li><p>diff 算法会帮助我们计算出虚拟 DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。</p></li><li><p>大概逻辑</p><p>Tree diff</p><ul><li>将新旧两棵树逐层对比，找出哪些节点需要更新</li><li>如果节点是组件就看 Component diff</li><li>如果节点是标签就看 Element diff</li></ul><p>Component diff</p><ul><li>如果节点是组件，就先看组件类型</li><li>类型不同直接替换（删除旧的）</li><li>类型相同则只更新属性</li><li>然后深入组件做 Tree diff（递归）</li></ul><p>Element diff</p><ul><li>如果节点是原生标签，则看标签名</li><li>标签名不同直接替换，相同则只更新属性</li><li>然后进入标签后代做 Tree diff（递归）</li></ul></li></ul><h4 id="2、DOM-diff-的问题"><a href="#2、DOM-diff-的问题" class="headerlink" title="2、DOM diff 的问题"></a>2、DOM diff 的问题</h4><ul><li>DOM diff 在同级对比时会出现 bug。由于计算机总是从上到下，从做左到右计算的，在同级别有多个节点，删除前面的节点时，会被 diff 算法认为是修改了前面的节点，删除了后面的节点，这就会导致渲染不符合预期。</li><li>解决方法是，在每一个节点增加一个唯一的 key 属性，用来标识节点。这也是 Vue 和 React 在使用循环时需要添加 key 属性的原因</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、虚拟-DOM&quot;&gt;&lt;a href=&quot;#一、虚拟-DOM&quot; class=&quot;headerlink&quot; title=&quot;一、虚拟 DOM&quot;&gt;&lt;/a&gt;一、虚拟 DOM&lt;/h2&gt;&lt;h4 id=&quot;1、虚拟-DOM-是什么？&quot;&gt;&lt;a href=&quot;#1、虚拟-DOM-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、虚拟 DOM 是什么？&quot;&gt;&lt;/a&gt;1、虚拟 DOM 是什么？&lt;/h4&gt;&lt;p&gt;一个能代表 DOM 树的对象，通常含有标签名、标签上的属性，事件监听以及其他属性&lt;/p&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://github.com/Straight-GZ/tags/React/"/>
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue3的一些新特性和一些问题</title>
    <link href="https://github.com/Straight-GZ/2020/12/11/Vue3/"/>
    <id>https://github.com/Straight-GZ/2020/12/11/Vue3/</id>
    <published>2020-12-11T15:18:15.000Z</published>
    <updated>2020-12-11T15:18:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Vue3-和-Vue2-的一些区别"><a href="#1、Vue3-和-Vue2-的一些区别" class="headerlink" title="1、Vue3 和 Vue2 的一些区别"></a>1、Vue3 和 Vue2 的一些区别</h4><ul><li>创建实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue3 新方法 createApp 其作用是构建实例</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">const app &#x3D; createApp(&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; Vue2 使用的是 new Vue() 构建实例</span><br></pre></td></tr></table></figure><ul><li><p>Vue3 支持碎片(Fragments)，就是说在组件可以拥有多个根节点</p></li><li><p>增<code>v-model</code>代替以前的<code>v-model</code>和<code>.sync</code></p></li><li><p>新增<code>context.emit</code>，与<code>this.$event</code>作用相同</p></li><li><p>具名插槽：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:content&gt;</span><br><span class="line">  &lt;strong&gt;hi&lt;&#x2F;strong&gt;</span><br><span class="line">  &lt;div&gt;你好&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;template v-slot:title&gt;</span><br><span class="line">  &lt;strong&gt;加粗的标签 &lt;&#x2F;strong&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;title&quot; &#x2F;&gt;  &#x2F;&#x2F;对应 v-slot:title</span><br><span class="line">    &lt;span @click&#x3D;&quot;close&quot; class&#x3D;&quot;lunzi-dialog-close&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">&lt;main&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;content&quot; &#x2F;&gt;  &#x2F;&#x2F;对应 v-slot:content</span><br><span class="line">&lt;&#x2F;main&gt;</span><br></pre></td></tr></table></figure><h4 id="2、组合式-api"><a href="#2、组合式-api" class="headerlink" title="2、组合式 api"></a>2、组合式 api</h4></li><li><p>setup 组件选项</p><ul><li><p>在创建组件之前执行，一旦 props 被解析，就作为组合式 API 的入口。接受两个参数 props 和 context</p></li><li><p>props:响应式的，当传入新的 prop 时，它将被更新。</p><p>不能使用 ES6 解构，因为它会消除 prop 的响应性，需要解构 prop，可以通过使用 setup 函数中的 toRefs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; toRefs &#125; from &#39;vue&#39;</span><br><span class="line">setup(props) &#123;</span><br><span class="line">const &#123; title &#125; &#x3D; toRefs(props)</span><br><span class="line">    console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Context:context 是一个普通的 JavaScript 对象，它暴露三个组件的 property</p><pre><code>export default &#123; setup(props, context) &#123;      // Attribute (非响应式对象)      console.log(context.attrs)     // 插槽 (非响应式对象)     console.log(context.slots)     // 触发事件 (方法)     console.log(context.emit) &#125;&#125;//可以使用es6解构export default &#123;  setup(props, &#123; attrs, slots, emit &#125;) &#123;  ...  &#125;&#125;</code></pre></li><li><p>执行 setup 时，组件实例尚未被创建，将无法访问组件选项：data、computed、methods</p></li></ul></li></ul><ul><li><p>带 ref 的响应式变量</p><p>接受参数，并将其包裹在一个带有 value property 的对象中返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">const counter &#x3D; ref(0)</span><br><span class="line">console.log(counter) &#x2F;&#x2F; &#123; value: 0 &#125;</span><br><span class="line">console.log(counter.value) &#x2F;&#x2F; 读</span><br><span class="line">counter.value++     &#x2F;&#x2F;写</span><br></pre></td></tr></table></figure></li><li><p>在 setup()中 methods、computed、watch、生命周期函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; computed, ref, onMounted,  watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">props: &#123;</span><br><span class="line">  title: String</span><br><span class="line">&#125;,</span><br><span class="line">setup (props, context) &#123;</span><br><span class="line">  const counter &#x3D; ref(0)</span><br><span class="line">  const &#123; user &#125; &#x3D; toRefs(props)</span><br><span class="line">  const add1&#x3D;()&#x3D;&gt;&#123;  &#x2F;&#x2F; context.emit代替this.$emit</span><br><span class="line">    context.emit(&#39;x&#39;,counter.value+1</span><br><span class="line">  &#125;</span><br><span class="line">  const add2 &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">    return counter.value+2</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(add1)</span><br><span class="line">  watch(user, add1)   &#x2F;&#x2F;return 之后才能在模板中使用</span><br><span class="line">  return &#123;counter,add1,add2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Teleport:允许我们控制在 DOM 中哪个父节点下呈现 HTML</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;teleport&gt;  &#x2F;&#x2F;将 div放在body里面</span><br></pre></td></tr></table></figure><h4 id="3、属性绑定"><a href="#3、属性绑定" class="headerlink" title="3、属性绑定"></a>3、属性绑定</h4></li></ul><p>默认所有属性都绑定到根元素</p><p>//<strong>Button.vue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot &#x2F;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>//<strong>ButtonDemo.vue</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;button 内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;h1&gt;示例&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;Button @click&#x3D;&quot;&quot; @focus&#x3D;&quot;&quot;&gt;按钮&lt;&#x2F;Button&gt; &#x2F;&#x2F;Button上所有时间属性</span><br><span class="line">  会绑定到Button组件跟元素上</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Button from &quot;..&#x2F;lib&#x2F;Button.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; Button &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>使用<code>inheritAttrs:false</code>可以取消默认绑定</li><li>使用<code>$attrs</code>或者 <code>context.attrs</code> 获取所有属性</li><li>使用 <code>v-bind=&#39;$attrs&#39;</code>批量绑定属性</li><li>使用<code>const &#123;size,onclick,...xxx&#125;=context.attrs</code>将属性分开</li></ul><p>props 和 attrs 的区别</p><ul><li>props 要先声明才能取值，attrs 不需要</li><li>props 不包含事件，attrs 包含</li><li>props 没有声明的属性，会跑到 attrs 里</li><li>props 支持 String 之外的类型，attrs 只支持 String 类型</li></ul><h4 id="4、context-slots-default"><a href="#4、context-slots-default" class="headerlink" title="4、context.slots.default()"></a>4、context.slots.default()</h4><p><strong>检查组件内部标签类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setup(props, context) &#123;</span><br><span class="line">  const defaults &#x3D; context.slots.default();</span><br><span class="line">  defaults.forEach((tag) &#x3D;&gt; &#123;</span><br><span class="line">     if (tag.type !&#x3D;&#x3D; Tab) &#123;</span><br><span class="line">       throw new Error(&quot;Tabs子标签必须是Tab标签);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Vue3-支持-TS-和-markdown"><a href="#5、Vue3-支持-TS-和-markdown" class="headerlink" title="5、Vue3 支持 TS 和 markdown"></a>5、Vue3 支持 TS 和 markdown</h4><p>支持 TS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shims.vue.d.ts</span><br><span class="line">declare module &quot;*.vue&quot; &#123;</span><br><span class="line">import &#123; ComponentOptions &#125; from &quot;vue&quot;;</span><br><span class="line">const componentOptions: ComponentOptions;</span><br><span class="line">export default componentOptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持 markdown</p><p>//shims.vue.d.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;*.md&quot; &#123;</span><br><span class="line">  const str: string;</span><br><span class="line">  export default str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin/md.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @ts-nocheck</span><br><span class="line">import path from &quot;path&quot;;</span><br><span class="line">import fs from &quot;fs&quot;;</span><br><span class="line">import marked from &quot;marked&quot;;</span><br><span class="line"></span><br><span class="line">const mdToJs &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">  const content &#x3D; JSON.stringify(marked(str));</span><br><span class="line">  return &#96;export default $&#123;content&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export function md() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    configureServer: [</span><br><span class="line">      &#x2F;&#x2F; 用于开发</span><br><span class="line">      async (&#123; app &#125;) &#x3D;&gt; &#123;</span><br><span class="line">        app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">          if (ctx.path.endsWith(&quot;.md&quot;)) &#123;</span><br><span class="line">            ctx.type &#x3D; &quot;js&quot;;</span><br><span class="line">            const filePath &#x3D; path.join(process.cwd(), ctx.path);</span><br><span class="line">            ctx.body &#x3D; mdToJs(fs.readFileSync(filePath).toString());</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            await next();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    transforms: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 用于 rollup</span><br><span class="line">        test: (context) &#x3D;&gt; context.path.endsWith(&quot;.md&quot;),</span><br><span class="line">        transform: (&#123; code &#125;) &#x3D;&gt; mdToJs(code),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1、Vue3-和-Vue2-的一些区别&quot;&gt;&lt;a href=&quot;#1、Vue3-和-Vue2-的一些区别&quot; class=&quot;headerlink&quot; title=&quot;1、Vue3 和 Vue2 的一些区别&quot;&gt;&lt;/a&gt;1、Vue3 和 Vue2 的一些区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;创建实例&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; Vue3 新方法 createApp 其作用是构建实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;#123; createApp &amp;#125; from &amp;#39;vue&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const app &amp;#x3D; createApp(&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; Vue2 使用的是 new Vue() 构建实例&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vue3 支持碎片(Fragments)，就是说在组件可以拥有多个根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增&lt;code&gt;v-model&lt;/code&gt;代替以前的&lt;code&gt;v-model&lt;/code&gt;和&lt;code&gt;.sync&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新增&lt;code&gt;context.emit&lt;/code&gt;，与&lt;code&gt;this.$event&lt;/code&gt;作用相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具名插槽：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>闭包和立即执行函数</title>
    <link href="https://github.com/Straight-GZ/2020/12/09/%E9%97%AD%E5%8C%85%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://github.com/Straight-GZ/2020/12/09/%E9%97%AD%E5%8C%85%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/</id>
    <published>2020-12-09T02:48:53.000Z</published>
    <updated>2020-12-09T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><pre><code>[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 的解释：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包</code></pre><h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><pre><code>1. 让外部访问函数内部变量成为可能；(隐藏变量)2. 局部变量会常驻在内存中；3. 可以避免使用全局变量，防止全局变量污染；</code></pre> <a id="more"></a><h4 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">let a&#x3D;1;</span><br><span class="line">function b()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">    a+&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line">const fn2&#x3D;fn1()</span><br><span class="line">fn2()   &#x2F;&#x2F;1</span><br><span class="line">fn2()   &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>这就是一个最简单的闭包，fn2 可以获取到函数内部的变量 a</code></pre><h3 id="二、立即调用函数表达式（IIFE）"><a href="#二、立即调用函数表达式（IIFE）" class="headerlink" title="二、立即调用函数表达式（IIFE）"></a>二、立即调用函数表达式（IIFE）</h3><ol><li>在定义时就直接执行的函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    let x&#x3D;1;</span><br><span class="line">    return x</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li>可以将立即执行函数分配给一个变量，变量将得到函数的返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> let a&#x3D;(function () &#123;</span><br><span class="line">    let x&#x3D;1;</span><br><span class="line">    return x</span><br><span class="line">&#125;)();</span><br><span class="line"> a &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure><strong>作用</strong>：由于立即执行函数内部变量无法访问，立即执行函数可以避免变量污染。</li></ol><h3 id="一个经典的面试题"><a href="#一个经典的面试题" class="headerlink" title="一个经典的面试题"></a>一个经典的面试题</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;&#x2F;&#x2F;输出 5个5</span><br></pre></td></tr></table></figure></code></pre><p>可以使用闭包和立即执行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 依次打出0~4</span><br></pre></td></tr></table></figure><p>或者把 var 改为 let</p><p>var 声明的 i 相当于是在全局作用域，在 for 循环结束之后才会执行，因此打出 5 个 5</p><p>而使用 let，会在每次执行 for 循环的时候重新创建一个变量 i，每次循环是一个新的作用域，因此不会打出 5 个 5</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、闭包&quot;&gt;&lt;a href=&quot;#一、闭包&quot; class=&quot;headerlink&quot; title=&quot;一、闭包&quot;&gt;&lt;/a&gt;一、闭包&lt;/h3&gt;&lt;h4 id=&quot;1、概念&quot;&gt;&lt;a href=&quot;#1、概念&quot; class=&quot;headerlink&quot; title=&quot;1、概念&quot;&gt;&lt;/a&gt;1、概念&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 的解释：
一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2、作用&quot;&gt;&lt;a href=&quot;#2、作用&quot; class=&quot;headerlink&quot; title=&quot;2、作用&quot;&gt;&lt;/a&gt;2、作用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. 让外部访问函数内部变量成为可能；(隐藏变量)

2. 局部变量会常驻在内存中；

3. 可以避免使用全局变量，防止全局变量污染；&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="闭包" scheme="https://github.com/Straight-GZ/tags/%E9%97%AD%E5%8C%85/"/>
    
    <category term="函数" scheme="https://github.com/Straight-GZ/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>React 基本用法</title>
    <link href="https://github.com/Straight-GZ/2020/12/04/React/"/>
    <id>https://github.com/Straight-GZ/2020/12/04/React/</id>
    <published>2020-12-04T07:30:23.000Z</published>
    <updated>2020-12-04T07:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、createElement-和-JSX"><a href="#一、createElement-和-JSX" class="headerlink" title="一、createElement 和 JSX"></a>一、createElement 和 JSX</h3><ol><li>createElement</li></ol><p>创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 ‘div’ 或 ‘span’），也可以是 React 组件 类型 （class 组件或函数组件）,代码编写复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">  &#39;h1&#39;,</span><br><span class="line">  &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">  &#39;Hello, world!&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>JSX<br>下面代码会被编译为和上面相同的代码，完全等价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">&lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">&lt;&#x2F;h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在 JSX 中给元素添加类, 需要使用 className 代替 class</li><li>JSX 中可以直接使用 {} 中间写 JS 代码<a id="more"></a></li></ul></li></ol><h3 id="二、class-组件和生命周期钩子"><a href="#二、class-组件和生命周期钩子" class="headerlink" title="二、class 组件和生命周期钩子"></a>二、class 组件和生命周期钩子</h3><p>1、 class 组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);   &#x2F;&#x2F;必须用super调用父类的constructor</span><br><span class="line">    this.state &#x3D; &#123;n: 1&#125;;</span><br><span class="line">&#125;</span><br><span class="line">add()&#123;this.setSTate((state)&#x3D;&gt;    &#x2F;&#x2F;使用函数</span><br><span class="line">     return &#123;n:this.state.n+1&#125;)&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;this.state.n&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt;this.add()&#125;&gt;+1&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 props 和 state</p><ul><li><p>props</p><ul><li>给组件传递数据，一般用在父子组件之间</li><li>React 把传递给组件的属性转化为一个对象并交给 props</li><li>props 是只读的，无法给 props 添加或修改属性</li><li>props.children：获取组件的内容</li></ul></li><li><p>state</p><ul><li>用来给组件提供组件内部使用的数据</li><li>只有通过 class 创建的组件才有，函数组件使用 useState</li><li>setState 是异步的，改变之后马上取取不到最新的值</li><li>setState 会自动合并第一层属性，useState 不会</li></ul></li></ul><p>3、生命周期钩子</p><ol><li><p>constructor</p><ul><li>初始化 props、state</li><li>此时不能调用 setState</li><li>bind this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;     &#x2F;&#x2F;如果只是初始化props 可以省略</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;n: 1&#125;;</span><br><span class="line">    this.onClick&#x3D;this.onClick.bind(this)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等价于 写在 constructor外面</span><br><span class="line">onClick&#x3D;()&#x3D;&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>shouldComponentUpdate</p></li></ol><ul><li>返回 false 阻止 UI 更新</li><li>返回 true 不阻止</li><li>作用：允许手动判断是否需要更新组件，避免不必要的更新</li><li>如果返回值为 false，那么，后续 render()方法不会被调用</li><li>可以使用 React.PureComponent 代替 React.Component,两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent">官方文档</a></li></ul><ol start="3"><li>render</li></ol><ul><li>展示视图</li><li>只能有一个根元素</li><li>多个根元素可以使用&lt;React.Fragment&gt;简写为 &lt;&gt;&lt;/&gt;</li><li>函数能够执行多次，只要组件的属性或状态改变了，这个方法就会重新执行</li></ul><ol start="4"><li>componentDidMount</li></ol><ul><li>组件已经挂载到页面中</li><li>可以进行 DOM 操作，比如获取 DOM 元素的宽高属性</li><li>可以<strong>发送请求</strong>获取数据（<strong>官方推荐</strong>）</li></ul><ol start="5"><li>componentDidUpdate</li></ol><ul><li><p>组件已经更新</p></li><li><p>不能修改状态 否则会循环渲染（除非条件判断）</p></li><li><p>首次渲染不会执行此方法</p></li><li><p>shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。</p></li><li><p>参数：旧的属性和状态对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>componentWillUnmount()</li></ol><ul><li>组件卸载,组件一辈子只能执行一次</li><li>执行清理工作，清除定时器等</li></ul><h3 id="三、函数组件和-hooks"><a href="#三、函数组件和-hooks" class="headerlink" title="三、函数组件和 hooks"></a>三、函数组件和 hooks</h3><p>1、函数组件</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Demo(props) &#123;</span><br><span class="line">const [n,setN]&#x3D;React.useState(0)</span><br><span class="line">return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2、hooks</p><ul><li><p>useState</p><ul><li>使用状态</li><li>不可局部更新，如果 state 是一个对象，并不会合并属性，可以使用…操作符</li><li>对象要改变地址，React 才认为数据改变了</li><li>初始化和 set 的时候可以使用函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [n,setN]&#x3D;React.useState(()&#x3D;&gt;&#123;return initialState&#125;))</span><br><span class="line"></span><br><span class="line">setN(x&#x3D;&gt;x+1)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>useReducer</p><p>useState 替代方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;      &#x2F;&#x2F;创建初始值</span><br><span class="line">function reducer(state, action) &#123;     &#x2F;&#x2F;创建所有操作</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">      case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">      case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">      default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> function Counter() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);    &#x2F;&#x2F;传给useReducer，获取读写操作</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">       &#x2F;&#x2F;调用对应操作</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>useContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const X&#x3D;React.createContext(null)     &#x2F;&#x2F;创建上下文</span><br><span class="line">function App()&#123;</span><br><span class="line">    const [n,setN]&#x3D;useState(0)</span><br><span class="line">    return (</span><br><span class="line">        &lt;X.Provider value&#x3D;&#123;&#123;n,setN&#125;&#125;&gt; &#x2F;&#x2F;划定区域 绑定数据</span><br><span class="line">          &lt;Demo1&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;X.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function Demo1()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Demo2&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function Demo2()&#123;</span><br><span class="line">    const &#123;n,setN&#125;&#x3D;useContext(X)     &#x2F;&#x2F;拿到数据</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;n&#125;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;()&#x3D;&gt;setN(x&#x3D;&gt;x+1)&#125;&gt;+1&lt;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>*使用 useReducer 和 useContext 代替 Redux**<br><a href="https://codesandbox.io/s/interesting-volhard-lfxpm">代码</a></p></li></ul><ul><li><p>useEffect</p><p>在函数组件中执行副作用操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;,[])    &#x2F;&#x2F;只在第一次渲染执行 相当于componentDidMount</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;,[x])    &#x2F;&#x2F;在数组中依赖变化时执行</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;)</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;&#125;  &#x2F;&#x2F; 在组件卸载时执行，清除计时器之类的操作</span><br><span class="line">&#125;)      &#x2F;&#x2F;每次渲染都执行</span><br></pre></td></tr></table></figure><p>useLayoutEffect:它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</p></li></ul><ul><li><p>useMemo、React.memo、useCallback</p><ol><li>React.memo：组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用,props 不变就不会重新渲染，<strong>如果 prop 是一个复杂对象，可以使用 useMemo</strong><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">文档</a></li><li>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。类似 Vue 的 computed</li><li>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</li></ol></li><li><p>useRef</p><ul><li>返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</li><li>React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。<strong>让函数组件在接受 props 之外，再接受一个 ref</strong><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">文档</a></li><li>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle">文档</a></li></ul></li><li><p>自定义 hook</p><p>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。<a href="https://codesandbox.io/s/recursing-darkness-zuo4b">例子</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、createElement-和-JSX&quot;&gt;&lt;a href=&quot;#一、createElement-和-JSX&quot; class=&quot;headerlink&quot; title=&quot;一、createElement 和 JSX&quot;&gt;&lt;/a&gt;一、createElement 和 JSX&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;createElement&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 ‘div’ 或 ‘span’），也可以是 React 组件 类型 （class 组件或函数组件）,代码编写复杂&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const element &amp;#x3D; React.createElement(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#39;h1&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;className: &amp;#39;greeting&amp;#39;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#39;Hello, world!&amp;#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;JSX&lt;br&gt;下面代码会被编译为和上面相同的代码，完全等价&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const element &amp;#x3D; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;h1 className&amp;#x3D;&amp;quot;greeting&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Hello, world!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;h1&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JSX 中给元素添加类, 需要使用 className 代替 class&lt;/li&gt;
&lt;li&gt;JSX 中可以直接使用 {} 中间写 JS 代码&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="React" scheme="https://github.com/Straight-GZ/tags/React/"/>
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Computed和watch的区别</title>
    <link href="https://github.com/Straight-GZ/2020/11/26/computed%E5%92%8Cwatch/"/>
    <id>https://github.com/Straight-GZ/2020/11/26/computed%E5%92%8Cwatch/</id>
    <published>2020-11-26T07:25:51.000Z</published>
    <updated>2020-11-26T07:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、computed"><a href="#1、computed" class="headerlink" title="1、computed"></a>1、computed</h3><ul><li><p>computed 虽然看上去是方法，但实际上是计算属性，因此，使用方法和属性的使用方法相同，不需要加括号。</p></li><li><p>computed 会根据依赖的数据动态显示，并且计算结果会被缓存，只有在依赖的数据发生变化的之后再次获取 computed 的值才会重新计算。</p><a id="more"></a></li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    users: &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      phone: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    _user: &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.users.name + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.users.phone;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users.name = value;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123;_user&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;name=&#x27;李四&#x27;&quot;&gt;setName&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>上述例子可以直接在模板字符串中写undefined:undefined ，模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。</p></blockquote><h3 id="2、watch"><a href="#2、watch" class="headerlink" title="2、watch"></a>2、watch</h3><ul><li>watch 是对数据 data 的监听回调，当所依赖的 data 变化时，执行回调，是异步的,会传入<code>newVal</code>和<code>oldVal</code>.</li><li>提供两个选项，<code>immediate</code>用来设置是否在第一次渲染的时候执行，<code>deep</code>用来设置要监听对象内部属性的变化<br><strong>示例</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      n: <span class="number">0</span>,</span><br><span class="line">      history: [],</span><br><span class="line">      isUndo: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.n += <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">undo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> last = <span class="built_in">this</span>.history.pop();</span><br><span class="line">      <span class="built_in">this</span>.isUndo = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">this</span>.n = last.from; <span class="comment">//触发watch异步更新</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//需要在上一步更新之后 再设置    setTimeout</span></span><br><span class="line">        <span class="built_in">this</span>.isUndo = <span class="literal">false</span>;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="function"><span class="title">n</span>(<span class="params">newN, oldN</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//当 this.isUndo为false 才会执行</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.isUndo) <span class="built_in">this</span>.history.push(&#123; <span class="attr">from</span>: oldN, <span class="attr">to</span>: newN &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">  &#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;hr&gt;</span></span><br><span class="line"><span class="string"> &lt;button @click=&#x27;add&#x27;&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string"> &lt;button @click=&#x27;undo&#x27;&gt;撤销&lt;/button&gt;</span></span><br><span class="line"><span class="string"> &lt;hr&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;history&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43acb00de3a401cb8714c3c978ef48b~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、computed&quot;&gt;&lt;a href=&quot;#1、computed&quot; class=&quot;headerlink&quot; title=&quot;1、computed&quot;&gt;&lt;/a&gt;1、computed&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;computed 虽然看上去是方法，但实际上是计算属性，因此，使用方法和属性的使用方法相同，不需要加括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;computed 会根据依赖的数据动态显示，并且计算结果会被缓存，只有在依赖的数据发生变化的之后再次获取 computed 的值才会重新计算。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="https://github.com/Straight-GZ/2020/11/24/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/Straight-GZ/2020/11/24/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-24T06:42:50.000Z</published>
    <updated>2020-11-24T06:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h4><p><strong><code>Vue</code>会遍历<code>data</code>对象的所有<code>property</code>，并使用<code>Object.defineProperty</code>把这些<code>property</code>全部转为<code>getter/setter</code>。通过<code>getter/setter</code>让 Vue 能够追踪依赖，在<code>property</code>被访问和修改时通知变更。</strong></p> <a id="more"></a><h4 id="二、Object-defineProperty-和-getter、setter"><a href="#二、Object-defineProperty-和-getter、setter" class="headerlink" title="二、Object.defineProperty 和 getter、setter"></a>二、Object.defineProperty 和 getter、setter</h4><p><code>Object.defineProperty</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> let data1 &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(data1, &quot;n&quot;, &#123;</span><br><span class="line">  value: 0</span><br><span class="line">&#125;);</span><br><span class="line">console.log(data1.n);  &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure><br><p><code>getter/setter</code>用于对属性的读写进行监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let myData2 &#x3D; &#123; n: 0 &#125;;</span><br><span class="line">let data2 &#x3D; proxy(&#123; data: myData2 &#125;); &#x2F;&#x2F; 括号里是匿名对象，无法访问</span><br><span class="line"></span><br><span class="line">function proxy(&#123; data &#125;) &#123;</span><br><span class="line">  let value &#x3D; data.n;</span><br><span class="line">  Object.defineProperty(data, &quot;n&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue &lt; 0) return;</span><br><span class="line">      value &#x3D; newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F;监听 data</span><br><span class="line"></span><br><span class="line">  const obj &#x3D; &#123;&#125;;</span><br><span class="line">  Object.defineProperty(obj, &quot;n&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return data.n;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">     if (newValue &lt; 0) return;</span><br><span class="line">      data.n &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return obj; &#x2F;&#x2F; obj 就是代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(data2.n);&#x2F;&#x2F;0</span><br><span class="line">myData2.n &#x3D; -1;</span><br><span class="line">console.log(data2.n);&#x2F;&#x2F;0</span><br><span class="line">myData2.n &#x3D; 1;</span><br><span class="line">console.log(data2.n);&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure><br><p><strong>当<code>let vm=new Vue(&#123;data:myData&#125;)</code>时，会让 vm 成为 Vue 的代理，对 myData 的所有属性进行监控，使得 myData 的属性变化的时候渲染页面。</strong></p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p><strong>Vue 的数据响应式，是通过<code>Object.defineProperty</code>将对象所有的属性转化为<code>getter/setter</code>来监控数据变化，即时渲染页面。</strong></p><p><strong>注意</strong>：Vue 不能检测到对象属性的添加或删除，解决方法是手动调用 Vue.set 或者 this.$set<br><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一、原理&quot;&gt;&lt;a href=&quot;#一、原理&quot; class=&quot;headerlink&quot; title=&quot;一、原理&quot;&gt;&lt;/a&gt;一、原理&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Vue&lt;/code&gt;会遍历&lt;code&gt;data&lt;/code&gt;对象的所有&lt;code&gt;property&lt;/code&gt;，并使用&lt;code&gt;Object.defineProperty&lt;/code&gt;把这些&lt;code&gt;property&lt;/code&gt;全部转为&lt;code&gt;getter/setter&lt;/code&gt;。通过&lt;code&gt;getter/setter&lt;/code&gt;让 Vue 能够追踪依赖，在&lt;code&gt;property&lt;/code&gt;被访问和修改时通知变更。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="框架" scheme="https://github.com/Straight-GZ/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://github.com/Straight-GZ/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack简单配置</title>
    <link href="https://github.com/Straight-GZ/2020/11/22/webpack/"/>
    <id>https://github.com/Straight-GZ/2020/11/22/webpack/</id>
    <published>2020-11-22T03:29:07.000Z</published>
    <updated>2020-11-22T03:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>Webpack 是一个模块打包工具(module bundler)，其最主要的功能就是模块打包，模块打包，通俗地说就是：找出模块之间的依赖关系，按照一定的规则把这些模块组织合并为一个 JavaScript 文件。Webpack 认为一切都是模块，JS 文件、CSS 文件、jpg/png 图片等等都是模块。</p><a id="more"></a><h4 id="2、-安装"><a href="#2、-安装" class="headerlink" title="2、 安装"></a>2、 安装</h4><ul><li><p>新建项目目录</p></li><li><p>在目录运行<code>npm init -y</code>,初始化 npm</p></li><li><p>安装 webpack<code>npm install webpack webpack-cli --save-dev</code></p></li></ul><h4 id="3、mode-模式"><a href="#3、mode-模式" class="headerlink" title="3、mode(模式)"></a>3、mode(模式)</h4><p>development（开发模式）和 production（生产模式）</p><ul><li>在开发环境中，SourceMap 更全，可以快速定位代码的问题</li></ul><ul><li>在开发环境中，代码一般不需要压缩；生产环境，代码会被压缩</li></ul><p>webpack-dev-server：能够用于快速开发应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const base &#x3D; require(&quot;.&#x2F;webpack.config.base.js&quot;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: &quot;development&quot;,</span><br><span class="line">  devtool: &quot;inline-source-map&quot;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;.&#x2F;dist&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用不同的webpack配置文件</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server&quot;,&#x2F;&#x2F;使用默认的</span><br><span class="line">    &quot;build&quot;: &quot;rm -rf dist &amp;&amp; webpack --config webpack.config.prod.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>webpack-merge</strong></p><h4 id="4、-入口和出口"><a href="#4、-入口和出口" class="headerlink" title="4、 入口和出口"></a>4、 入口和出口</h4><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>output 属性告诉 webpack 在哪里输出它所创建的文件，以及如何命名这些文件，默认值为 <code>./dist</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),   &#x2F;&#x2F;默认值</span><br><span class="line">    filename: &#39;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、-浏览器缓存和-hash"><a href="#5、-浏览器缓存和-hash" class="headerlink" title="5、 浏览器缓存和 hash"></a>5、 浏览器缓存和 hash</h4><ul><li>浏览器缓存：<ul><li>当浏览器访问一个 html 页面时，html 页面会加载 JS、CSS 和图片等外部资源，这需要花费一定的下载时间。由于很多资源是长时间不变的，因此可以把这些资源存储在本地，这样就不需要花时间下载。</li><li>可以通过响应头，<code>cache-control</code>设置缓存时间</li><li>如果文件变化了，可以设置一个新的文件名，这样在请求的时候浏览器就知道文件改变了，而请求新的文件</li><li>只要内容不变，就文件名可以一直使用</li></ul></li></ul><ul><li><p>Webpack 与 hash 算法</p><ul><li><p>在使用 Webpack 对构建的时候，Webpack 会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack 就会计算出一个新的特殊字符串。</p></li><li><p>hash/chunkhash/contenthash:<br>hash 所有文件哈希值相同； chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值； contenthash 计算与文件内容本身相关.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &quot;[name].[contenthash].js&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://webpack.docschina.org/configuration/output/#template-strings">可替换的内容</a></p></li></ul></li></ul><h4 id="6、loader-和-plugin"><a href="#6、loader-和-plugin" class="headerlink" title="6、loader 和 plugin"></a>6、loader 和 plugin</h4><h5 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h5><ul><li><p>babel-loader<br>主要作用是在 Webpack 打包的时候，用 Babel 将 ES6 的代码转换成 ES5 版本的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">   &#123;</span><br><span class="line">     test: &#x2F;\.js$&#x2F;,</span><br><span class="line">     exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">     use: &#123;</span><br><span class="line">       loader: &#39;babel-loader&#39;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>加载 CSS 文件<br>使用 style-loader 和 css-loader 这两个 loader 来处理 CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure><p>SCSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">   use: [</span><br><span class="line">     &quot;style-loader&quot;,</span><br><span class="line">     &quot;css-loader&quot;,</span><br><span class="line">     &#123;</span><br><span class="line">       loader: &quot;sass-loader&quot;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         implementation: require(&quot;dart-sass&quot;),   &#x2F;&#x2F;使用dart-sass 代替 node-sass</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.styl$&#x2F;,</span><br><span class="line">  use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.less$&#x2F;,</span><br><span class="line">  use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>css-loader 的作用是解析 CSS 文件，包括解析@import 等 CSS 自身的语法。把 CSS 文件解析后，以字符串的形式打包到 JS 文件中。</li><li>style-loader 就来发挥作用了，它可以把 JS 里的样式代码插入到 html 文件里。它的原理很简单，就是通过 JS 动态生成 style 标签插入到 html 文件的 head 标签里。</li></ul></li></ul><h5 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h5><ul><li>HtmlWebpackPlugin<br>生成 HTML5 文件，使用 script 标签将您的所有捆绑包包括在内。<br><a href="https://github.com/jantimon/html-webpack-plugin#configuration">html-webpack-plugin</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    &#x2F;&#x2F;设置标题</span><br><span class="line">    title: &quot;标题&quot;,</span><br><span class="line">    &#x2F;&#x2F;模板文件路径</span><br><span class="line">    template: &quot;src&#x2F;assets&#x2F;index.html&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>MiniCssExtractPlugin</p><p>将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">plugins: [new MiniCssExtractPlugin()],</span><br><span class="line">module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;i,</span><br><span class="line">      use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;],</span><br><span class="line">      &#125;,</span><br><span class="line">   ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7、loader-和-plugin-的区别"><a href="#7、loader-和-plugin-的区别" class="headerlink" title="7、loader 和 plugin 的区别"></a>7、loader 和 plugin 的区别</h4><p>loader，它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。例:babel-loader 将 JS 文件转换为浏览器可以识别的更低版本的 JS</p><p>plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。例：MiniCssExtractPlugin 可以将 CSS 抽离成一个文件</p><h4 id="8、webpack-懒加载"><a href="#8、webpack-懒加载" class="headerlink" title="8、webpack 懒加载"></a>8、webpack 懒加载</h4><p>在用户执行某些操作的时候，再加载某些模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;lazy.js</span><br><span class="line">export default function fn() &#123;</span><br><span class="line">console.log(&quot;懒加载&quot;)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> button.onclick &#x3D; e &#x3D;&gt; import(.&#x2F;lazy.js&#39;).then(module &#x3D;&gt; &#123;</span><br><span class="line">   let fn &#x3D; module.default;</span><br><span class="line">   fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; class=&quot;headerlink&quot; title=&quot;1、简介&quot;&gt;&lt;/a&gt;1、简介&lt;/h4&gt;&lt;p&gt;Webpack 是一个模块打包工具(module bundler)，其最主要的功能就是模块打包，模块打包，通俗地说就是：找出模块之间的依赖关系，按照一定的规则把这些模块组织合并为一个 JavaScript 文件。Webpack 认为一切都是模块，JS 文件、CSS 文件、jpg/png 图片等等都是模块。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://github.com/Straight-GZ/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="webpack" scheme="https://github.com/Straight-GZ/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>MVC</title>
    <link href="https://github.com/Straight-GZ/2020/11/21/MVC/"/>
    <id>https://github.com/Straight-GZ/2020/11/21/MVC/</id>
    <published>2020-11-21T07:05:24.000Z</published>
    <updated>2020-11-21T07:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h4><p>MVC 包括三类对象:</p><ol><li>模型 model 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。<a id="more"></a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const m &#x3D; &#123;</span><br><span class="line">  data: &#123;存储数据&#125;,</span><br><span class="line">  create() &#123;添加数据&#125;,</span><br><span class="line">  delete() &#123;删除数据&#125;,</span><br><span class="line">  update(data) &#123;     更新数据</span><br><span class="line">    eventBus.trigger()触发事件</span><br><span class="line">  &#125;,</span><br><span class="line">  get() &#123;读取数据&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>视图 view 是它在屏幕上的表示，描绘的是 model 的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const v &#x3D; &#123;</span><br><span class="line">  el: 渲染标记,</span><br><span class="line">  html: &#96;页面内容&#96;,</span><br><span class="line">  init()&#123;初始化页面&#125;,</span><br><span class="line">  render()&#123;渲染页面&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>控制器 controller 定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据 model 上的改变。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const c &#x3D; &#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    v.init(container)   初始化view</span><br><span class="line">    v.render() 第一次渲染</span><br><span class="line">    c.autoBindEvents()自动绑定事件</span><br><span class="line">    eventBus.on()&#123;&#125;监听事件</span><br><span class="line">    &#125;,</span><br><span class="line">  events: &#123;哈希表记录事件&#125;,</span><br><span class="line">  autoBindEvents() &#123;自动绑定事件&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、EventBus"><a href="#二、EventBus" class="headerlink" title="二、EventBus"></a>二、EventBus</h4><p>EventBus 事件总线,可以用来进行组件之间的监听和通信。</p><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;</span><br><span class="line">const eventBus &#x3D; $(window)</span><br></pre></td></tr></table></figure><ul><li>api:<code>eventBus.trigger()</code>:触发事件；<code>eventBus.on()&#123;&#125;</code>：监听事件;<code>eventBus.off()&#123;&#125;</code>:解除事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const m &#x3D; &#123;</span><br><span class="line">...</span><br><span class="line">   update(data) &#123;</span><br><span class="line">   ...</span><br><span class="line">    eventBus.trigger(&#39;m:updated&#39;)&#x2F;&#x2F;在更新数据时触发事件</span><br><span class="line">  &#125;,</span><br><span class="line">const c &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">    eventBus.on(&#39;m:updated&#39;, () &#x3D;&gt; &#123;v.render(m.data.n)&#125;)</span><br><span class="line">  &#125;,&#x2F;&#x2F;接收事件，事件触发就执行后面的函数</span><br><span class="line">  const</span><br><span class="line"></span><br><span class="line">  eventBus.off(&#39;m:updated&#39;)&#x2F;&#x2F;移除事件</span><br></pre></td></tr></table></figure><h4 id="三、表驱动编程"><a href="#三、表驱动编程" class="headerlink" title="三、表驱动编程"></a>三、表驱动编程</h4><p>简单来说，就是以查表的方式获取数据而不使用逻辑语句。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。<br>从表中查询数据主要有直接访问、索引访问、阶梯访问三种方式。</p><p>例：今天星期几</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const day &#x3D; new Date().getDay()</span><br><span class="line">let day_zh;</span><br><span class="line">if(day &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">    day_zh &#x3D; &#39;星期日&#39;</span><br><span class="line">&#125;else if(day &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    day_zh &#x3D; &#39;星期一&#39;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else&#123;</span><br><span class="line">    day_zh &#x3D; &#39;星期六&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者 用 switch case</span><br><span class="line">switch(day) &#123;</span><br><span class="line">    case 0:</span><br><span class="line">        day_zh &#x3D; &#39;星期日&#39;</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        day_zh &#x3D; &#39;星期一&#39;</span><br><span class="line">        break;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用表驱动法，将数据放在一个表里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const week &#x3D; [&#39;星期日&#39;, &#39;星期一&#39;,..., &#39;星期六&#39;]</span><br><span class="line">const day &#x3D; new Date().getDay(</span><br><span class="line">const day_zh &#x3D; week[day]</span><br></pre></td></tr></table></figure><h4 id="四、如何理解模块化的"><a href="#四、如何理解模块化的" class="headerlink" title="四、如何理解模块化的"></a>四、如何理解模块化的</h4><p>模块化就是将一个复杂的程序，通过一定规则封装成不同的模块，可以是对象、文件等。降低代码耦合度，各个模块有更好的独立性。这样做可以解决项目中的全局变量污染的问题，使开发效率更高，方便代码复用和维护 。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一、MVC&quot;&gt;&lt;a href=&quot;#一、MVC&quot; class=&quot;headerlink&quot; title=&quot;一、MVC&quot;&gt;&lt;/a&gt;一、MVC&lt;/h4&gt;&lt;p&gt;MVC 包括三类对象:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型 model 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="MVC" scheme="https://github.com/Straight-GZ/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session</title>
    <link href="https://github.com/Straight-GZ/2020/11/20/Cookie%E5%92%8CSession/"/>
    <id>https://github.com/Straight-GZ/2020/11/20/Cookie%E5%92%8CSession/</id>
    <published>2020-11-20T02:48:53.000Z</published>
    <updated>2020-11-20T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h3><ul><li><p>概述：</p><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<br>通俗的说，Cookie 是服务器下发给浏览器的一段字符串<br>浏览器必须保存这个 Cookie(除非用户删除)<br>之后发起相同二级域名请求，浏览器必须附上 Cookie<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">MDN</a></p><a id="more"></a></li></ul><ul><li>创建 Cookie<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie 名&gt;&#x3D;&lt;cookie 值&gt;</span><br><span class="line">&#x2F;&#x2F;例</span><br><span class="line">response.setHeader(&quot;Set-Cookie&quot;, &#96;session_id&#x3D;$&#123;random&#125;;HttpOnly&#96;);</span><br></pre></td></tr></table></figure><h3 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h3></li></ul><p>session 数据放在服务器上,一般由 cookie 保存 session 的 id，保存在 Cookie 里的 session id 是独一无二的随机生成的，服务器通过 Cookie 保存的 session id 获取数据</p><h3 id="3、两者区别"><a href="#3、两者区别" class="headerlink" title="3、两者区别"></a>3、两者区别</h3><ol><li><p>存储位置：cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p></li><li><p>安全性：cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行篡改</p></li><li><p>限制：单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</p></li></ol><p>简单实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;sign_in&quot; &amp;&amp; method &#x3D;&#x3D;&#x3D; &quot;POST&quot;) &#123;</span><br><span class="line">  const array &#x3D; [];</span><br><span class="line">  const users &#x3D; JSON.parse(fs.readFileSync(&quot;.&#x2F;db&#x2F;users.json&quot;).toString());</span><br><span class="line">  response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html,charset&#x3D;UTF-8&quot;);</span><br><span class="line">  request.on(&quot;data&quot;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">    array.push(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  request.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    const string &#x3D; Buffer.concat(array).toString();</span><br><span class="line">    const obj &#x3D; JSON.parse(string);</span><br><span class="line">    const user &#x3D; users.find(</span><br><span class="line">      (user) &#x3D;&gt; user.name &#x3D;&#x3D;&#x3D; obj.name &amp;&amp; user.password &#x3D;&#x3D;&#x3D; obj.password</span><br><span class="line">    );</span><br><span class="line">    if (user &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      response.statusCode &#x3D; 400;</span><br><span class="line">      response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response.statusCode &#x3D; 200;</span><br><span class="line">      const random &#x3D; Math.random();</span><br><span class="line">      session[random] &#x3D; &#123; user_id: user.id &#125;;</span><br><span class="line">      fs.writeFileSync(&quot;.&#x2F;session.json&quot;, JSON.stringify(session));</span><br><span class="line">      response.setHeader(&quot;Set-Cookie&quot;, &#96;session_id&#x3D;$&#123;random&#125;;HttpOnly&#96;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;home.html&quot;) &#123;</span><br><span class="line">  const cookie &#x3D; request.headers[&quot;cookie&quot;];</span><br><span class="line">  let sessionId;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    sessionId &#x3D; cookie</span><br><span class="line">      .split(&quot;;&quot;)</span><br><span class="line">      .filter((s) &#x3D;&gt; s.indexOf(&quot;session_id&#x3D;&quot;) &gt;&#x3D; 0)[0]</span><br><span class="line">      .split(&quot;&#x3D;&quot;)[1];</span><br><span class="line">    console.log(sessionId);</span><br><span class="line">  &#125; catch (error) &#123;&#125;</span><br><span class="line">  if (sessionId &amp;&amp; session[sessionId]) &#123;</span><br><span class="line">    const userId &#x3D; session[sessionId].user_id;</span><br><span class="line">    console.log(userId);</span><br><span class="line">    const homeHtml &#x3D; fs.readFileSync(&quot;.&#x2F;public&#x2F;home.html&quot;).toString();</span><br><span class="line">    const users &#x3D; JSON.parse(fs.readFileSync(&quot;.&#x2F;db&#x2F;users.json&quot;).toString());</span><br><span class="line">    const user &#x3D; users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId);</span><br><span class="line">    let string;</span><br><span class="line">    if (user) &#123;</span><br><span class="line">      string &#x3D; homeHtml</span><br><span class="line">        .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;已登录&quot;)</span><br><span class="line">        .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, user.name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      string &#x3D; homeHtml</span><br><span class="line">        .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;未登录&quot;)</span><br><span class="line">        .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    response.write(string);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const homeHtml &#x3D; fs.readFileSync(&quot;.&#x2F;public&#x2F;home.html&quot;).toString();</span><br><span class="line">    const string &#x3D; homeHtml</span><br><span class="line">      .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;未登录&quot;)</span><br><span class="line">      .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, &quot;&quot;);</span><br><span class="line">    response.write(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cookie-V-S-LocalStorage-V-S-SessionStorage-V-S-Session"><a href="#Cookie-V-S-LocalStorage-V-S-SessionStorage-V-S-Session" class="headerlink" title="Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session"></a>Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session</h4><ul><li><p>Cookie V.S. LocalStorage</p><p>主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会<br>Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）</p></li></ul><ul><li><p>LocalStorage V.S. SessionStorage</p><p>LocalStorage 一般不会自动过期（除非用户手动清除），而 SessionStorage 在回话结束时过期（如关闭浏览器）</p></li><li><p>Cookie V.S. Session</p><p>Cookie 存在浏览器的文件里，Session 存在服务器的文件里<br>Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、Cookie&quot;&gt;&lt;a href=&quot;#1、Cookie&quot; class=&quot;headerlink&quot; title=&quot;1、Cookie&quot;&gt;&lt;/a&gt;1、Cookie&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;概述：&lt;/p&gt;
&lt;p&gt;HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。&lt;br&gt;通俗的说，Cookie 是服务器下发给浏览器的一段字符串&lt;br&gt;浏览器必须保存这个 Cookie(除非用户删除)&lt;br&gt;之后发起相同二级域名请求，浏览器必须附上 Cookie&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="HTTP" scheme="https://github.com/Straight-GZ/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>跨域 CORS和JSON</title>
    <link href="https://github.com/Straight-GZ/2020/11/18/%E8%B7%A8%E5%9F%9F%20CORS%E5%92%8CJSONP/"/>
    <id>https://github.com/Straight-GZ/2020/11/18/%E8%B7%A8%E5%9F%9F%20CORS%E5%92%8CJSONP/</id>
    <published>2020-11-18T02:48:53.000Z</published>
    <updated>2020-11-18T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h4><ol><li>同源定义：</li></ol><ul><li>源： window.Origin 或 location.origin 可以得到当前源</li><li>源=协议+域名+端口号</li><li>如果两个 url 协议、域名、端口号完全一致，那么这两个 url 就是同源的<a id="more"></a></li></ul><ol start="2"><li>同源策略：</li></ol><ul><li>浏览器规定：如果 JS 运行在源 A，那么就只能获取源 A 的数据，不允许获取源 B 的数据，即不允许跨源</li><li>目的：保护隐私</li><li>主要原因：无法区分发送者，如果没有同源策略，任何网站都可以访问别的网站数据(检查 referer)</li><li>同源策略：不同源的页面中间，不允许互相访问数据</li></ul><ul><li>同源策略限制访问数据，引用 css、JS 和图片的时候，其实并不知道其内容，只是在引用</li></ul><h4 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h4><p>浏览器有同源策略限制，不允许一个源里的文档访问另一个源里资源。而跨域就是为了解决同源策略限制。</p><ul><li><p>CORS：<br>跨源资源共享，使用附加的 HTTP 头来告诉浏览器，准许运行在一个源上的 Web 应用访问位于另一不同源选定的资源。使用<strong>Access-Control-Allow-Origin</strong>响应头可以指定一个可以访问资源的 URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;friends.json&quot;) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;json;charset&#x3D;utf-8&quot;)</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;crystal.com:9999&quot;)</span><br><span class="line">    response.write(fs.readFileSync(&quot;public&#x2F;friends.json&quot;))</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JSONP ：在无法使用 CORS 跨域的情况下，请求 JS 文件，这个 JS 文件会执行一个回调，回调里面包含数据。可以兼容 IE 浏览器实现跨域，但只能发 get 请求，并且无法读取精确的状态码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">     const random &#x3D; &quot;crystalJSONPCallbackName&quot; + Math.random()</span><br><span class="line">     window[random] &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">       resolve(data)</span><br><span class="line">     &#125;</span><br><span class="line">     const script &#x3D; document.createElement(&quot;script&quot;)</span><br><span class="line">     script.src &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;random&#125;&#96;</span><br><span class="line">     script.onload &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F;无法获取状态码，只能知道成功或者失败</span><br><span class="line">       script.remove()</span><br><span class="line">     &#125;</span><br><span class="line">     script.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">       reject()</span><br><span class="line">     &#125;</span><br><span class="line">     document.body.appendChild(script)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> jsonp(&quot;http:&#x2F;&#x2F;qq.com:8888&#x2F;friends.js&quot;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">   console.log(data)</span><br><span class="line"> &#125;)</span><br><span class="line"> script.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">   console.log(window.xxx)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;friends.js&quot;) &#123;</span><br><span class="line">  if (request.headers[&quot;referer&quot;].indexOf(&quot;http:&#x2F;&#x2F;crystal.com:9999&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;javascript;charset&#x3D;utf-8&quot;)</span><br><span class="line">    const string &#x3D; &#96;window[&quot;&#123;&#123;xxx&#125;&#125;&quot;](&#123;&#123;data&#125;&#125;)&#96;</span><br><span class="line">    const data &#x3D; fs.readFileSync(&quot;public&#x2F;friends.json&quot;).toString()</span><br><span class="line">    const string2 &#x3D; string</span><br><span class="line">      .replace(&quot;&#123;&#123;data&#125;&#125;&quot;, data)</span><br><span class="line">      .replace(&quot;&#123;&#123;xxx&#125;&#125;&quot;, query.callback)     &#x2F;&#x2F;上面的random</span><br><span class="line">    response.write(string2)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一、同源策略&quot;&gt;&lt;a href=&quot;#一、同源策略&quot; class=&quot;headerlink&quot; title=&quot;一、同源策略&quot;&gt;&lt;/a&gt;一、同源策略&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;同源定义：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;源： window.Origin 或 location.origin 可以得到当前源&lt;/li&gt;
&lt;li&gt;源=协议+域名+端口号&lt;/li&gt;
&lt;li&gt;如果两个 url 协议、域名、端口号完全一致，那么这两个 url 就是同源的&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="AJAX" scheme="https://github.com/Straight-GZ/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>异步与Promise</title>
    <link href="https://github.com/Straight-GZ/2020/11/16/%E5%BC%82%E6%AD%A5%E5%92%8CPromise/"/>
    <id>https://github.com/Straight-GZ/2020/11/16/%E5%BC%82%E6%AD%A5%E5%92%8CPromise/</id>
    <published>2020-11-16T07:23:36.000Z</published>
    <updated>2020-11-16T07:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、异步与同步"><a href="#一、异步与同步" class="headerlink" title="一、异步与同步"></a>一、异步与同步</h3><p>同步:一定要当前任务执行完，才会执行下一个任务。</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fn1&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">  return &#39;结果&#39;</span><br><span class="line">&#125;</span><br><span class="line">const fn2&#x3D;()&#x3D;&gt;&#123;&#125;</span><br><span class="line">let x&#x3D;fn1()  &#x2F;&#x2F;拿到fn1的返回值之后才会执行下一句</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p>异步：不等任务执行完，就执行下一个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn1 &#x3D; function(callback)&#123;</span><br><span class="line">  const result &#x3D; setTimeout(function()&#123;</span><br><span class="line">    callback(&#39;结果&#39;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">fn1(function callback(x)&#123;</span><br><span class="line">  console.log(x)  &#x2F;&#x2F;别的代码执行完，再回来执行</span><br><span class="line">&#125;)</span><br><span class="line">fn2() &#x2F;&#x2F;先执行这一句</span><br></pre></td></tr></table></figure><h3 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h3><p>Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。</p><h4 id="1、-创建-Promise"><a href="#1、-创建-Promise" class="headerlink" title="1、 创建 Promise"></a>1、 创建 Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  if()&#123;</span><br><span class="line">    resolve(someValue)</span><br><span class="line">    &#x2F;&#x2F; fulfilled 已兑现: 意味着操作成功完成。</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    rejected()</span><br><span class="line">    &#x2F;&#x2F;reject(&quot;failure reason&quot;) 已拒绝: 意味着操作失败</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>构造函数接受一个函数作为参数</li></ul><ul><li>调用构造函数得到实例 promise 的同时，作为参数的函数会立即执行</li><li>参数函数接受两个回调函数参数 resolve 和 reject</li></ul><ul><li>在参数函数被执行的过程中，如果在其内部调用 resolve，会将 promise 的状态变成 fulfilled，或者调用 reject，会将 promise 的状态变成 rejected</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(()&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;  resolve，执行这里</span><br><span class="line">&#125;,()&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; reject 执行这里</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>待定状态（pending）的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个原因（错误）被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。</p><h4 id="2、Promise-的作用"><a href="#2、Promise-的作用" class="headerlink" title="2、Promise 的作用"></a>2、Promise 的作用</h4><ul><li>解决回调地狱的问题（避免了层层嵌套的回调函数）</li><li>语法非常简洁。Promise 对象提供了简洁的 API，使得控制异步操作更加容易</li></ul><h4 id="3、Promise-的使用"><a href="#3、Promise-的使用" class="headerlink" title="3、Promise 的使用"></a>3、Promise 的使用</h4><ul><li>new Promise：创建 Promise 实例</li><li>.then 和 .catch 和 .finally<ul><li><code>.then</code>:返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</li><li>返回一个 Promise，并且处理拒绝的情况。(相当于只有一个参数的.then)</li><li>finally() 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。<br>这避免了同样的语句需要在 then()和 catch()中各写一次的情况。</li></ul></li></ul><ul><li><p>Promise.all/Promise.race/Promise.reject/Promise.resolve</p><ul><li><p>Promise.all() 方法接收一个 promise 的数组，并且只返回一个 Promise 实例，它的 resolve 回调会在所有的 Promise 的 resolve 都执行结束之后，才会调用，它的 reject 回调只要有任何一个 Promise 的 reject 被执行，就会被调用</p></li><li><p>Promise.race(),接受 Promise 数组，返回一个 promise，一旦某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p></li><li><p>Promise.reject(reason)返回一个带有拒绝原因的 Promise 对象。</p></li><li><p>Promise.resolve(value) 方法返回一个以给定值解析后的 Promise 对象,value 可以是带有.then 方法的对象，也可以是 Promise(将直接返回这个 Promise)</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const promise1&#x3D;Promise.resolve(1)</span><br><span class="line">const promise2&#x3D;Promise.resolve(promise1)</span><br><span class="line">promise1&#x3D;&#x3D;&#x3D;promise2 &#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p>接受带有.then 方法的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出错误之后resolve</span><br><span class="line">let x &#x3D; &#123; then: function(resolve) &#123;</span><br><span class="line">  throw new Error(&quot;错误&quot;);</span><br><span class="line">  resolve(&quot;Resolving&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">let y &#x3D; Promise.resolve(x);</span><br><span class="line">y.then(function(v) &#123;</span><br><span class="line">    &#x2F;&#x2F;不会执行</span><br><span class="line">&#125;, function(e) &#123;</span><br><span class="line">  console.log(e);   &#x2F;&#x2F;打出错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出错误之前 resolve</span><br><span class="line">let m &#x3D; &#123; then: function(resolve) &#123;</span><br><span class="line">  resolve(&quot;完成&quot;);</span><br><span class="line">  throw new Error(&quot;错误&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">var n &#x3D; Promise.resolve(m);</span><br><span class="line">n.then(function(v) &#123;</span><br><span class="line">  console.log(v); &#x2F;&#x2F; 输出&quot;完成&quot;</span><br><span class="line">&#125;, function(e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被调用</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4></li></ul></li></ul><p><a href="https://es6.ruanyifeng.com/#docs/promise">阮一峰 ECMAScript 6 入门</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、异步与同步&quot;&gt;&lt;a href=&quot;#一、异步与同步&quot; class=&quot;headerlink&quot; title=&quot;一、异步与同步&quot;&gt;&lt;/a&gt;一、异步与同步&lt;/h3&gt;&lt;p&gt;同步:一定要当前任务执行完，才会执行下一个任务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://github.com/Straight-GZ/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>跨域 CORS和JSON</title>
    <link href="https://github.com/Straight-GZ/2020/11/13/ajax/"/>
    <id>https://github.com/Straight-GZ/2020/11/13/ajax/</id>
    <published>2020-11-13T02:48:53.000Z</published>
    <updated>2020-11-13T02:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>概述</li></ol><p>AJAX：Asynchronous JavaScript + XML（）</p><ul><li>AJAX 是浏览器上的功能，浏览器可以发请求，收响应</li><li>浏览器在 window 上加了一个 XMLHttpRequest 函数</li></ul><ul><li>用这个构造函数（类）可以构造出一个对象<br>JS 通过它实现发请求，收响应<a id="more"></a></li></ul><ol start="2"><li>使用</li></ol><ul><li>JS 代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const request &#x3D; new XMLHttpRequest()</span><br><span class="line">request.open(&quot;GET&quot;, &quot;&#x2F;style.css&quot;)</span><br><span class="line">request.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(request.readyState)</span><br><span class="line">    if (request.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (request.status &gt;&#x3D; 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">             console.log(&quot;下载完成了&quot;)</span><br><span class="line">            const style &#x3D; document.createElement(&quot;style&quot;)</span><br><span class="line">            style.innerHTML &#x3D; request.response</span><br><span class="line">             document.head.appendChild(style)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;加载 css 失败&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;server.js</span><br><span class="line">var http &#x3D; require(&quot;http&quot;)</span><br><span class="line">var fs &#x3D; require(&quot;fs&quot;)</span><br><span class="line">var url &#x3D; require(&quot;url&quot;)</span><br><span class="line">var port &#x3D; process.argv[2]</span><br><span class="line"></span><br><span class="line">if (!port) &#123;</span><br><span class="line">console.log(&quot;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&quot;)</span><br><span class="line">process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer(function (request, response) &#123;</span><br><span class="line">var parsedUrl &#x3D; url.parse(request.url, true)</span><br><span class="line">var pathWithQuery &#x3D; request.url</span><br><span class="line">var queryString &#x3D; &quot;&quot;</span><br><span class="line">if (pathWithQuery.indexOf(&quot;?&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">    queryString &#x3D; pathWithQuery.substring(pathWithQuery.indexOf(&quot;?&quot;))</span><br><span class="line">&#125;</span><br><span class="line">var path &#x3D; parsedUrl.pathname</span><br><span class="line">var query &#x3D; parsedUrl.query</span><br><span class="line">var method &#x3D; request.method</span><br><span class="line"></span><br><span class="line">console.log(&quot;有个傻子发请求过来啦！路径（带查询参数）为：&quot; + pathWithQuery)</span><br><span class="line"></span><br><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;index.html&quot;) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf-8&quot;)</span><br><span class="line">    let string &#x3D; fs.readFileSync(&quot;public&#x2F;index.html&quot;).toString()</span><br><span class="line">    const page1 &#x3D; fs.readFileSync(&quot;db&#x2F;page1.json&quot;).toString()</span><br><span class="line">    const array &#x3D; JSON.parse(page1)</span><br><span class="line">    const result &#x3D; array.map((item) &#x3D;&gt; &#96;&lt;li&gt;$&#123;item.id&#125;&lt;&#x2F;li&gt;&#96;).join(&quot;&quot;)</span><br><span class="line">    string &#x3D; string.replace(&quot;&#123;&#123;page1&#125;&#125;&quot;, &#96;&lt;ul id&#x3D;&quot;aa&quot;&gt;$&#123;result&#125;&lt;&#x2F;ul&gt;&#96;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    response.statusCode &#x3D; 404</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;css;charset&#x3D;utf-8&quot;)</span><br><span class="line">    response.write(&#96;你访问的页面不存在&#96;)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(</span><br><span class="line">&quot;监听 &quot; +</span><br><span class="line">    port +</span><br><span class="line">    &quot; 成功\n请用在空中转体720度然后用电饭煲打开 http:&#x2F;&#x2F;localhost:&quot; +</span><br><span class="line">    port</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AJAX：Asynchronous JavaScript + XML（）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AJAX 是浏览器上的功能，浏览器可以发请求，收响应&lt;/li&gt;
&lt;li&gt;浏览器在 window 上加了一个 XMLHttpRequest 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;用这个构造函数（类）可以构造出一个对象&lt;br&gt;JS 通过它实现发请求，收响应&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="AJAX" scheme="https://github.com/Straight-GZ/tags/AJAX/"/>
    
  </entry>
  
</feed>
