<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC是什么？</title>
    <url>/2021/03/09/BFC/</url>
    <content><![CDATA[<h3 id="1、BFC-概念"><a href="#1、BFC-概念" class="headerlink" title="1、BFC 概念"></a>1、BFC 概念</h3><ul>
<li>块格式化上下文（Block Formatting Context，BFC），是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</li>
<li>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<a id="more"></a>

</li>
</ul>
<h3 id="2、触发-BFC"><a href="#2、触发-BFC" class="headerlink" title="2、触发 BFC"></a>2、触发 BFC</h3><p>常见触发 BFC 的方式</p>
<ul>
<li>根元素（html）</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>overflow 计算值(Computed)不为 visible 的块元素</li>
<li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li>
<li>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</li>
</ul>
<h3 id="4、BFC-的特性"><a href="#4、BFC-的特性" class="headerlink" title="4、BFC 的特性"></a>4、BFC 的特性</h3><ol>
<li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列.</li>
<li>盒子垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li>
</ol>
<p>BFC 是一个独立的渲染区域，它规定了内部如何布局，与外部互不干涉</p>
<h3 id="5、BFC-的应用"><a href="#5、BFC-的应用" class="headerlink" title="5、BFC 的应用"></a>5、BFC 的应用</h3><ol>
<li><p>避免外边距重叠</p>
<p>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p>
</li>
<li><p>清楚浮动<br>浮动的元素会脱离普通文档流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"> .test1&#123;</span><br><span class="line">     border:1px solid red;</span><br><span class="line"> &#125;</span><br><span class="line"> .test2&#123;</span><br><span class="line">     float:left;</span><br><span class="line">     width:100px;</span><br><span class="line">     height:100px;</span><br><span class="line">     border:1px solid black;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;div class&#x3D;test1&gt;</span><br><span class="line">     &lt;div class&#x3D;test2&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/09/ILwB5DpFQ8RzmCr.png" alt="image-20210309124909376"></p>
<p>这时候只要触发容器<code>test1</code>的 BFC 就可以清除浮动<br><img src="https://i.loli.net/2021/03/09/v3rmNdEZKQfALyi.png" alt="image-20210309125307615"></p>
</li>
<li><p>BFC 可以阻止元素被浮动元素覆盖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.test1&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     height:100px;</span><br><span class="line">     border:1px solid red;</span><br><span class="line">     float:left;</span><br><span class="line"> &#125;</span><br><span class="line"> .test2&#123;</span><br><span class="line"> border:1px solid black;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;test1&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;test2&gt;文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/09/C7VMyNGY8c5eRhp.png" alt="image-20210309125831884"><br>此时，只需要触发<code>test2</code>的 BFC 就可以解决</p>
<p>这种方法也可以实现一侧固定宽度，一侧自适应的两栏布局。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位</title>
    <url>/2021/03/09/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>布局是屏幕平面上的，<strong>定位是垂直于屏幕的</strong></p>
<h2 id="1、盒模型："><a href="#1、盒模型：" class="headerlink" title="1、盒模型："></a>1、盒模型：</h2><ul>
<li>背景的范围：border<strong>外边沿</strong>围城的区域（包括 border）</li>
<li>从左边看 div：background 在文字后面<a id="more"></a>

</li>
</ul>
<h2 id="2、div-的分层："><a href="#2、div-的分层：" class="headerlink" title="2、div 的分层："></a>2、div 的分层：<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce8ce3604b684f15a9c8dd9638198a4b~tplv-k3u1fbpfcp-watermark.webp"></h2><p>浮动元素脱离文档流：浮起来一点点</p>
<h2 id="3、position-属性"><a href="#3、position-属性" class="headerlink" title="3、position 属性"></a>3、position 属性</h2><ul>
<li><p>static：默认值，待在文档流里</p>
</li>
<li><p>relative：相对定位，升起来，但不脱离文档流</p>
<ul>
<li><p>使用场景：</p>
<p>1.用于做位移（很少用） 2.用于给 absolute 做爸爸</p>
</li>
<li><p>配合 z-index</p>
<p>z-index： auto 默认值，不创建新层叠上下文 可以取 0 正负整数</p>
</li>
</ul>
</li>
<li><p>absolute：绝对定位，定位基准是祖先里的非 static</p>
<ul>
<li><p>使用场景</p>
<p>1、脱离原来的位置，另起一层（对话框里的关闭按钮）</p>
<p>2、鼠标提示</p>
</li>
<li><p>注意：</p>
<p>1、某些浏览器如果不写 top/left 位置会错乱</p>
<p>2、善用<code>left:100%</code> 善用<code>left:50%</code> 加负 margin</p>
</li>
</ul>
</li>
<li><p>fixed： 固定定位，定位基准是 viewPort （父元素有 transform）</p>
<ul>
<li>使用场景：广告、回到顶部按钮</li>
<li>注意：手机上尽量不要使用，bug 很多。</li>
</ul>
</li>
<li><p>sticky： 粘滞定位</p>
</li>
</ul>
<p>经验：</p>
<ul>
<li>如果写了 absolute，一般都得补一个 relative</li>
<li>如果写了 absolute 或 fixed，一定要补 top 和 left；</li>
<li>sticky 兼容性差</li>
</ul>
<p><strong>例子</strong>：<a href="http://js.jirengu.com/lumad/17/edit?html,css,output">http://js.jirengu.com/lumad/17/edit?html,css,output</a></p>
<h2 id="4、z-index"><a href="#4、z-index" class="headerlink" title="4、z-index"></a>4、z-index</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038b80cb9d3d4f8a86fa8b07d2d81f18~tplv-k3u1fbpfcp-watermark.webp"></p>
<p>取值：</p>
<ul>
<li>auto：不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。</li>
<li>整型数字：生成的盒子在当前堆叠上下文中的堆叠层级。此盒子也会创建一个堆叠层级为 0 的本地堆叠上下文。这意味着后代（元素）的 z-indexes 不与此元素的外部元素的 z-indexes 进行对比。</li>
</ul>
<p>层叠上下文：</p>
<ul>
<li><p>每个层叠上下文就是一个新的小世界</p>
</li>
<li><p>每个小世界里的 z-index 跟外界无关</p>
</li>
<li><p>处在同一小世界的 z-index 才能比较</p>
</li>
<li><p>哪些属性可以创建它</p>
<p>z-index/flex/opacity/transform <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">层叠上下文 MDN</a></p>
</li>
</ul>
<p><strong>负 margin 与层叠上下文：负 z-index 逃不出小世界</strong></p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/03/09/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1、git-本地仓库"><a href="#1、git-本地仓库" class="headerlink" title="1、git 本地仓库"></a>1、git 本地仓库</h2><p>git 就是一条命令</p>
<p>六行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name 你的英文名</span><br><span class="line">git config --global user.email 你的邮箱</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<h3 id="1-让你代码有版本："><a href="#1-让你代码有版本：" class="headerlink" title="1.让你代码有版本："></a>1.让你代码有版本：</h3><p>git init :初始化（指定目录），创建 .git 目录</p>
<p><strong>git add</strong> 路径:选择哪些变动是需要提交的</p>
<p>.gitignore：描述哪些文件是不需要提交的</p>
<p>git commit -m ：字符串：提交，说明理由 （字符串有空格，用引号）</p>
<p><strong>git commit -v</strong>：回顾修改的内容，添加详细提交理由<strong>（推荐）</strong></p>
<p>git reset –hard 提交号前六位：回到指定提交版本</p>
<p>git log： 查看历史 git reflog：查看所有的历史</p>
<h3 id="2-分支："><a href="#2-分支：" class="headerlink" title="2.分支："></a>2.分支：</h3><p>git branch ：基于当前 commit 创建分支，在哪个分支提交，就创建在哪个分支</p>
<p>git checkout：切换分支</p>
<p>git merge:合并分支</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><p>选择需要保留的分支 master</p>
</li>
<li><p>运行 git merge x（合并的分支）</p>
</li>
<li><p>冲突</p>
<ul>
<li><p>发现冲突：</p>
<p>合并分支的时候<strong>conflict</strong>提示</p>
<p>使用 git status -sb 查看冲突文件</p>
</li>
<li><p>解决冲突：</p>
<p>依次打开文件</p>
<p>搜素‘====’四个等于号</p>
<p>选择要保留的代码，删除不用的代码</p>
<p>删除’====‘’&lt;&lt;&lt;&lt;’’&gt;&gt;&gt;&gt;’标记</p>
<p><strong>git add 对应文件</strong></p>
<p>再次使用 git status -sb 解决下一个冲突文件</p>
<p>直到没有冲突，运行<strong>git commit （不需要加选项）</strong></p>
</li>
</ul>
</li>
<li><p>合并完删除无用的分支 git branch -d x</p>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>git 目录就是本地仓库</li>
<li>git add 处理的是文件变化，而不是文件，删除文件后，依然需要 git add 添加到提交区</li>
<li>常用的命令：<strong>git add</strong> 和<strong>git commit -v</strong></li>
</ul>
<h2 id="2、git-远程仓库"><a href="#2、git-远程仓库" class="headerlink" title="2、git 远程仓库"></a>2、git 远程仓库</h2><h3 id="生成-ssh-key（帮助文档）："><a href="#生成-ssh-key（帮助文档）：" class="headerlink" title="生成 ssh key（帮助文档）："></a>生成 ssh key（<a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" title="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#">帮助文档</a>）：</h3><ul>
<li>运行 ssh-keygen -t rsa -b 4096 -C +邮箱地址</li>
<li>一直回车键到没有提示</li>
<li>cat ~/.ssh/id_rsa.pub 得到公钥内容，复制内容</li>
<li>打开 Github，在设置页面粘贴公钥内容</li>
</ul>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><ul>
<li>运行 ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a></li>
<li>询问 yes/no,回答 yes</li>
</ul>
<h3 id="上传代码："><a href="#上传代码：" class="headerlink" title="上传代码："></a>上传代码：</h3><ol>
<li><p>新建 Github Repo，复制 ssh 地址</p>
</li>
<li><p>运行 git remote add origin git@xxxxx</p>
<p>（在本地添加远程仓库地址，origin 为远程仓库默认名字）</p>
</li>
<li><p>git push -u origin master</p>
</li>
</ol>
<ul>
<li>推送本地 master 分支到远程 originmaster 分支</li>
<li>提示应该 git pull…</li>
<li>-u origin master 意思为设置上游分支，之后不用再设置，直接 git pull，git push</li>
</ul>
<p><strong>上传其它分支：</strong></p>
<p>一：git push x:x</p>
<p>二：git checkout x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin x</span><br></pre></td></tr></table></figure>
<p><strong>上传到两个本地仓库</strong></p>
<ul>
<li>git remote add origin2 git@xxxxx</li>
<li>git push -u origin master</li>
</ul>
<p><strong>git pull 冲突</strong>：查看合并分支冲突</p>
<h3 id="下载代码："><a href="#下载代码：" class="headerlink" title="下载代码："></a>下载代码：</h3><ol>
<li> git clone git@xxx</li>
<li> 不同机器需要先上传新的 ssh key(一机一 key)</li>
<li> <strong>cd 目标路径</strong></li>
<li> 运行 git add/git commit/[git pull]/git push</li>
</ol>
<p>下载某个分支：先下载整个仓库，再切换分支</p>
<p><strong>git clone</strong>：</p>
<ul>
<li><p>git clone git@?/xxx.git:会在当前目录下创建一个 xxx 目录，xxx/.git 是本地仓库，一般需要接 cd xxx 进入目录</p>
</li>
<li><p>git clone git@?/xxx.git yyy：会在本地新建一个 yyy 目录，cd yyy 进入目录</p>
</li>
<li><p>git clone git@?/xxx.git .:最后一个字符是点，使用当前目录容纳代码和.git，需要先新建一个目录，cd 进入目录</p>
</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>常用命令：git alone/git pull/git push</p>
<p>远程仓库：本地仓库的备份，要先 commit 到本地仓库，然后 push 到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无法下载部分代码，只能先clone整个仓库生成ssh key（[帮助文档](https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;free-pro-team@latest&#x2F;github&#x2F;authenticating-to-github&#x2F;generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#)）：</span><br></pre></td></tr></table></figure>
<ul>
<li>运行 ssh-keygen -t rsa -b 4096 -C +邮箱地址</li>
<li>一直回车键到没有提示</li>
<li>cat ~/.ssh/id_rsa.pub 得到公钥内容，复制内容</li>
<li>打开 Github，在设置页面粘贴公钥内容</li>
</ul>
<h3 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h3><ul>
<li>运行 ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a></li>
<li>询问 yes/no,回答 yes</li>
</ul>
<h3 id="上传代码：-1"><a href="#上传代码：-1" class="headerlink" title="上传代码："></a>上传代码：</h3><ol>
<li><p>新建 Github Repo，复制 ssh 地址</p>
</li>
<li><p>运行 git remote add origin git@xxxxx</p>
<p>（在本地添加远程仓库地址，origin 为远程仓库默认名字）</p>
</li>
<li><p>git push -u origin master</p>
</li>
</ol>
<ul>
<li>推送本地 master 分支到远程 originmaster 分支</li>
<li>提示应该 git pull…，就运行 git pull!</li>
<li>-u origin master 意思为设置上游分支，之后不用再设置，直接 git pull，git push</li>
</ul>
<p><strong>上传其它分支：</strong></p>
<p>一：git push x:x</p>
<p>二：git checkout x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin x</span><br></pre></td></tr></table></figure>
<p><strong>上传到两个本地仓库</strong></p>
<ul>
<li>git remote add origin2 git@xxxxx</li>
<li>git push -u origin master</li>
</ul>
<p><strong>git pull 冲突</strong>：查看合并分支冲突</p>
<h3 id="下载代码：-1"><a href="#下载代码：-1" class="headerlink" title="下载代码："></a>下载代码：</h3><ol>
<li> git clone git@xxx</li>
<li> 不同机器需要先上传新的 ssh key(一机一 key)</li>
<li> <strong>cd 目标路径</strong></li>
<li> 运行 git add/git commit/[git pull]/git push</li>
</ol>
<p>下载某个分支：先下载整个仓库，再切换分支</p>
<p><strong>git clone</strong>：</p>
<ul>
<li><p>git clone git@?/xxx.git:会在当前目录下创建一个 xxx 目录，xxx/.git 是本地仓库，一般需要接 cd xxx 进入目录</p>
</li>
<li><p>git clone git@?/xxx.git yyy：会在本地新建一个 yyy 目录，cd yyy 进入目录</p>
</li>
<li><p>git clone git@?/xxx.git .:最后一个字符是点，使用当前目录容纳代码和.git，需要先新建一个目录，cd 进入目录</p>
</li>
</ul>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>常用命令：git alone/git pull/git push</p>
<p>远程仓库：本地仓库的备份，要先 commit 到本地仓库，然后 push 到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无法下载部分代码，只能先clone整个仓库</span><br></pre></td></tr></table></figure>
<h2 id="3、git-高级操作"><a href="#3、git-高级操作" class="headerlink" title="3、git 高级操作"></a>3、git 高级操作</h2><p>bash alias 简化命令： ga=”git add” gc=”git commit -v” gl=”git pull” gp=”git push” gco=”git checkout” gst=”git status -sb”</p>
<p>美化历史命令：git rebase -i xxx</p>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简述CSS三种布局</title>
    <url>/2021/03/09/CSS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="一、布局概述"><a href="#一、布局概述" class="headerlink" title="一、布局概述"></a>一、布局概述</h3><p>布局就是把页面分成一块一块，按左中右、上中下等排列。</p>
<p>1、布局分类：</p>
<ul>
<li><strong>固定宽度布局</strong>，一般为 960/1000/1024px</li>
<li><strong>不固定布局</strong>，主要靠文档流的原理来布局（文档流是自适应，不需要加额外样式）</li>
<li><strong>响应式布局</strong>，PC 上固定宽度，手机不固定宽度，混合布局<a id="more"></a>

</li>
</ul>
<p>2、布局思路</p>
<p>从大到小：先定下大局，然后完善每个部分的小布局</p>
<p>从小到大：先完成小布局，然后组合成大布局</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5cd5a0716644d2285941d447eb0c92d~tplv-k3u1fbpfcp-watermark.webp"></p>
<h3 id="二、float-布局"><a href="#二、float-布局" class="headerlink" title="二、float 布局"></a>二、float 布局</h3><p>步骤：</p>
<ul>
<li><p>在子元素上加 float:left 和 width</p>
</li>
<li><p>在父元素上加.clearfix（不要忘了加）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验：</p>
</li>
<li><p>留一些空间或者最后一个不设 width，或者设置一个最大宽度</p>
</li>
<li><p>IE6/7 存在双倍 margin bug</p>
</li>
</ul>
<p>实践：</p>
<ul>
<li>float 两栏布局（顶部条）：<code>float:left; </code> <code>clearfix</code></li>
<li>float 三栏布局（内容区）</li>
<li>float 四栏布局（导航栏）</li>
<li>float 平均布局（产品展示）需要在内容外再加一层，使用负 margin</li>
</ul>
<h3 id="三、flex-布局"><a href="#三、flex-布局" class="headerlink" title="三、flex 布局"></a>三、flex 布局</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。</p>
<h4 id="flex-的两个轴"><a href="#flex-的两个轴" class="headerlink" title="flex 的两个轴"></a>flex 的两个轴</h4><ol>
<li>主轴</li>
</ol>
<ul>
<li>由<code>flex-direction</code>定义</li>
<li>取值：row(水平方向)/row-reserve/column(垂直方向)/column-reserve</li>
</ul>
<ol start="2">
<li>交叉轴</li>
</ol>
<ul>
<li>交叉轴垂直于主轴</li>
<li><code>flex-direction</code> 为 <code>row</code> 或者 <code>row-reverse</code> ，交叉轴的方向就是垂直方向。</li>
<li>相反亦然</li>
</ul>
<h4 id="flex-容器"><a href="#flex-容器" class="headerlink" title="flex 容器"></a>flex 容器</h4><ol>
<li><p>实现 flex</p>
<p>需要将指定一个容器，将容器的<code>display</code>属性值改为 <code>flex</code> 或者 <code>inline-flex</code>，容器中的直系子元素就会变为 <strong>flex 元素</strong>。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p>
<ol start="2">
<li>容器的属性</li>
</ol>
<ul>
<li><p>flex-direction:<strong>决定主轴的方向(项目的排列方向)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值：row，主轴为水平方向，起点在左端，row-reverse：主轴为水平方向，起点在右端；</p>
<p>​ column：主轴为垂直方向，起点在上沿，column-reverse：主轴为垂直方向，起点在下沿</p>
</li>
<li><p><strong>flex-wrap: 决定容器内项目是否可换行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值：<strong>nowrap</strong> 不换行,当空间不足时，子元素会缩小。</p>
<p>​ wrap：项目太大而无法全部显示在一行中，则会换行显示，第一行在上方</p>
<p>​ wrap-reverse：换行，第一行在下方</p>
</li>
<li><p><strong>justify-content：定义了项目在主轴的对齐方式。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值: flex-start 左对齐,flex-end：右对齐,center：居中</p>
<p>​ space-between：两端对齐，剩余空间等分成间隙。</p>
<p>​ space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。</p>
</li>
<li><p>align-items: 可以使元素在交叉轴方向对齐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值为 <code>stretch</code> 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。</p>
<p><code>flex-start</code>，使 flex 元素按 flex 容器的顶部对齐, <code>flex-end</code> 使它们按 flex 容器的下部对齐, 或者<code>center</code>使它们居中对齐.</p>
</li>
</ul>
<p>三、Flex 项目属性：</p>
<ol>
<li><p>order</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p>
</li>
<li><p>flex-grow: <strong>定义项目的放大比例</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值为 0，即如果存在剩余空间，也不放大</p>
<p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p>
<p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>
</li>
<li><p>flex-shrink:<strong>定义了项目的缩小比例</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>flex: <strong>flex-grow, flex-shrink 和 flex-basis 的简写</strong></p>
<p>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item &#123;flex: 1;&#125;   &#x2F;&#x2F;等价的</span><br><span class="line">.item &#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 0%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%</li>
<li>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</li>
<li>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%</li>
<li>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1</li>
</ul>
</li>
<li><p>align-self：<strong>允许单个项目有与其他项目不一样的对齐方式</strong></p>
<p>单个项目覆盖 align-items 定义的属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、Grid-布局"><a href="#四、Grid-布局" class="headerlink" title="四、Grid 布局"></a>四、Grid 布局</h3></li>
<li><p>成为 container</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 行和列</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">25%</span> <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8b97e7942049fea47f4bb92abc0f8b~tplv-k3u1fbpfcp-watermark.webp"></p>
<ol start="3">
<li>给每条线取名字：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>:</span><br><span class="line">    [first] <span class="number">40px</span> [line2] <span class="number">50px</span> [line3] auto</span><br><span class="line">    [col4-start] <span class="number">50px</span> [five] <span class="number">40px</span> [end];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:</span><br><span class="line">    [row1-start] <span class="number">25%</span> [row1-end] <span class="number">100px</span> [third-line]</span><br><span class="line">    auto [last-line];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>items 可以设置范围</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: five;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: row1-start;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>fr（free space） 份 可以和像素混用</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分区 grid-template-areas</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  &quot;<span class="selector-tag">head</span> <span class="selector-tag">head</span>&quot;</span><br><span class="line">  &quot;<span class="selector-tag">nav</span>  <span class="selector-tag">main</span>&quot;</span><br><span class="line">  &quot;<span class="selector-tag">nav</span>  <span class="selector-tag">foot</span>&quot;; <span class="comment">/* 区域划分 当前为 三行 两列 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &gt; <span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: head; <span class="comment">/*  指定当前元素所在的区域位置, 从grid-template-areas选取值 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#8ca0ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session</title>
    <url>/2021/03/09/Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<h3 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h3><ul>
<li><p>概述：</p>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<br>通俗的说，Cookie 是服务器下发给浏览器的一段字符串<br>浏览器必须保存这个 Cookie(除非用户删除)<br>之后发起相同二级域名请求，浏览器必须附上 Cookie<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">MDN</a></p>
<a id="more"></a>
</li>
</ul>
<ul>
<li>创建 Cookie<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie 名&gt;&#x3D;&lt;cookie 值&gt;</span><br><span class="line">&#x2F;&#x2F;例</span><br><span class="line">response.setHeader(&quot;Set-Cookie&quot;, &#96;session_id&#x3D;$&#123;random&#125;;HttpOnly&#96;);</span><br></pre></td></tr></table></figure>
<h3 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h3></li>
</ul>
<p>session 数据放在服务器上,一般由 cookie 保存 session 的 id，保存在 Cookie 里的 session id 是独一无二的随机生成的，服务器通过 Cookie 保存的 session id 获取数据</p>
<h3 id="3、两者区别"><a href="#3、两者区别" class="headerlink" title="3、两者区别"></a>3、两者区别</h3><ol>
<li><p>存储位置：cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>
</li>
<li><p>安全性：cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行篡改</p>
</li>
<li><p>限制：单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</p>
</li>
</ol>
<p>简单实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;sign_in&quot; &amp;&amp; method &#x3D;&#x3D;&#x3D; &quot;POST&quot;) &#123;</span><br><span class="line">  const array &#x3D; [];</span><br><span class="line">  const users &#x3D; JSON.parse(fs.readFileSync(&quot;.&#x2F;db&#x2F;users.json&quot;).toString());</span><br><span class="line">  response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html,charset&#x3D;UTF-8&quot;);</span><br><span class="line">  request.on(&quot;data&quot;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">    array.push(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  request.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">    const string &#x3D; Buffer.concat(array).toString();</span><br><span class="line">    const obj &#x3D; JSON.parse(string);</span><br><span class="line">    const user &#x3D; users.find(</span><br><span class="line">      (user) &#x3D;&gt; user.name &#x3D;&#x3D;&#x3D; obj.name &amp;&amp; user.password &#x3D;&#x3D;&#x3D; obj.password</span><br><span class="line">    );</span><br><span class="line">    if (user &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      response.statusCode &#x3D; 400;</span><br><span class="line">      response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response.statusCode &#x3D; 200;</span><br><span class="line">      const random &#x3D; Math.random();</span><br><span class="line">      session[random] &#x3D; &#123; user_id: user.id &#125;;</span><br><span class="line">      fs.writeFileSync(&quot;.&#x2F;session.json&quot;, JSON.stringify(session));</span><br><span class="line">      response.setHeader(&quot;Set-Cookie&quot;, &#96;session_id&#x3D;$&#123;random&#125;;HttpOnly&#96;);</span><br><span class="line">      response.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;home.html&quot;) &#123;</span><br><span class="line">  const cookie &#x3D; request.headers[&quot;cookie&quot;];</span><br><span class="line">  let sessionId;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    sessionId &#x3D; cookie</span><br><span class="line">      .split(&quot;;&quot;)</span><br><span class="line">      .filter((s) &#x3D;&gt; s.indexOf(&quot;session_id&#x3D;&quot;) &gt;&#x3D; 0)[0]</span><br><span class="line">      .split(&quot;&#x3D;&quot;)[1];</span><br><span class="line">    console.log(sessionId);</span><br><span class="line">  &#125; catch (error) &#123;&#125;</span><br><span class="line">  if (sessionId &amp;&amp; session[sessionId]) &#123;</span><br><span class="line">    const userId &#x3D; session[sessionId].user_id;</span><br><span class="line">    console.log(userId);</span><br><span class="line">    const homeHtml &#x3D; fs.readFileSync(&quot;.&#x2F;public&#x2F;home.html&quot;).toString();</span><br><span class="line">    const users &#x3D; JSON.parse(fs.readFileSync(&quot;.&#x2F;db&#x2F;users.json&quot;).toString());</span><br><span class="line">    const user &#x3D; users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId);</span><br><span class="line">    let string;</span><br><span class="line">    if (user) &#123;</span><br><span class="line">      string &#x3D; homeHtml</span><br><span class="line">        .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;已登录&quot;)</span><br><span class="line">        .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, user.name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      string &#x3D; homeHtml</span><br><span class="line">        .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;未登录&quot;)</span><br><span class="line">        .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    response.write(string);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const homeHtml &#x3D; fs.readFileSync(&quot;.&#x2F;public&#x2F;home.html&quot;).toString();</span><br><span class="line">    const string &#x3D; homeHtml</span><br><span class="line">      .replace(&quot;&#123;&#123;loginStatus&#125;&#125;&quot;, &quot;未登录&quot;)</span><br><span class="line">      .replace(&quot;&#123;&#123;userName&#125;&#125;&quot;, &quot;&quot;);</span><br><span class="line">    response.write(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Cookie-V-S-LocalStorage-V-S-SessionStorage-V-S-Session"><a href="#Cookie-V-S-LocalStorage-V-S-SessionStorage-V-S-Session" class="headerlink" title="Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session"></a>Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session</h4><ul>
<li><p>Cookie V.S. LocalStorage</p>
<p>主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会<br>Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）</p>
</li>
</ul>
<ul>
<li><p>LocalStorage V.S. SessionStorage</p>
<p>LocalStorage 一般不会自动过期（除非用户手动清除），而 SessionStorage 在回话结束时过期（如关闭浏览器）</p>
</li>
<li><p>Cookie V.S. Session</p>
<p>Cookie 存在浏览器的文件里，Session 存在服务器的文件里<br>Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML常用标签</title>
    <url>/2021/03/09/HTML5%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h4 id="一、a-标签"><a href="#一、a-标签" class="headerlink" title="一、a 标签"></a>一、a 标签</h4><ol>
<li>属性：</li>
</ol>
<ul>
<li><p>href：</p>
<p>取值：</p>
<ol>
<li>网址：</li>
</ol>
<ul>
<li><a href="https://www.baidu.com/">https://www.baidu.com</a></li>
<li><a href="http://www.baidu.com/">http://www.baidu.com</a></li>
<li>//<a href="http://www.baidu.com(用这个就可以了)/">www.baidu.com（用这个就可以了）</a></li>
</ul>
<ol start="2">
<li>路径：</li>
</ol>
<ul>
<li>/a/b/c 和 a/b/c：（绝对路径和相对路径，使用 http-server 效果相同）</li>
<li>index.html 以及./index.html</li>
</ul>
<ol start="3">
<li>伪协议<a id="more"></a>
</li>
</ol>
<ul>
<li>javascript:代码（”javascript:;”可用于实现 点击没有任何操作)</li>
<li>mailto:邮箱</li>
<li>tel：手机号</li>
</ul>
<ol start="4">
<li>id</li>
</ol>
<ul>
<li>href=#xxx 锚点链接</li>
</ul>
</li>
<li><p>target：</p>
<ol>
<li>内置名字</li>
</ol>
<ul>
<li><p>_blank：新窗口打开。</p>
</li>
<li><p>_top:</p>
<p>顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于<code>_self</code></p>
</li>
<li><p>_parent：</p>
<p>上层窗口打开，这通常用于从父窗口打开的子窗口，或者<code>&lt;iframe&gt;</code>里面的链接。如果当前窗口没有上层窗口，这个值等同于<code>_self</code></p>
</li>
<li><p>_self：当前窗口打开，这是默认值。</p>
</li>
</ul>
<ol start="2">
<li>程序员命名</li>
</ol>
<ul>
<li><p>window 的 name</p>
<p>两个页面都在同一个名叫 test 的窗口打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;foo.com&quot; target&#x3D;&quot;test&quot;&gt;foo&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;bar.com&quot; target&#x3D;&quot;test&quot;&gt;bar&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>iframe 的 name</p>
</li>
</ul>
</li>
<li><p>download：</p>
<ol>
<li>作用：不是打开页面，而是下载页面</li>
<li>问题：不是有浏览器都支持</li>
</ol>
</li>
<li><p>rel=noopener：</p>
</li>
</ul>
<ol start="2">
<li>作用：</li>
</ol>
<ul>
<li>跳转到外部页面</li>
<li>跳转到内部页面</li>
<li>跳转到邮箱或者号码</li>
</ul>
<h4 id="二、table-标签：表格"><a href="#二、table-标签：表格" class="headerlink" title="二、table 标签：表格"></a>二、table 标签：表格</h4><p>相关的标签：</p>
<ul>
<li><p>table：表格</p>
</li>
<li><p>thead：表头</p>
</li>
<li><p>tbody：主体</p>
</li>
<li><p>tfoot：表格末尾</p>
</li>
<li><p>tr：行</p>
</li>
<li><p>td：数据单元格</p>
</li>
<li><p>th：表头，标题单元格</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">      &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;th&gt;学号&lt;&#x2F;th&gt;</span><br><span class="line">          &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;&#x2F;thead&gt;</span><br><span class="line">      &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;td&gt;001&lt;&#x2F;td&gt;</span><br><span class="line">          &lt;td&gt;张三&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;td&gt;002&lt;&#x2F;td&gt;</span><br><span class="line">          &lt;td&gt;李四&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;&#x2F;tbody&gt;</span><br><span class="line">      &lt;tfoot&gt;&lt;&#x2F;tfoot&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>
<p>相关样式：</p>
<p>table-layout</p>
<p>border-collapse</p>
<p>border-spacing</p>
<h4 id="三、img-标签："><a href="#三、img-标签：" class="headerlink" title="三、img 标签："></a>三、img 标签：</h4><p>作用：</p>
<p>发出 get 请求，展示一张图片</p>
<p>属性：</p>
<ul>
<li><p>src：指定图片网址</p>
<p><code>&lt;img src=&quot;foo.jpg&quot;&gt;</code></p>
</li>
<li><p>Alt:图片说明。加载失败显示。</p>
<p><code>&lt;img src=&quot;foo.jpg&quot; alt=&quot;示例图片&quot;&gt;</code></p>
</li>
<li><p>height、width：指定高度、宽度 只指定一个，另一个自适应</p>
</li>
</ul>
<p>事件：</p>
<p>onload/onerror （加载成功/加载失败）</p>
<p>响应式：</p>
<p><code>max-width:100%</code> 最大宽度为 100%</p>
<h4 id="四、form：表单标签"><a href="#四、form：表单标签" class="headerlink" title="四、form：表单标签"></a>四、form：表单标签</h4><p>作用：发 get 或 post 的请求，然后刷新页面</p>
<p>属性：</p>
<p>action：服务器接收数据的 url</p>
<p>autocomplete：是否自动填充（配合 input 标签<code>name=&quot;username&quot;</code>使用，会有用户名建议）</p>
<p>method：提交数据的 HTTP 方法 （post 或 get）</p>
<p>target：在哪个窗口展示返回数据</p>
<p>事件：onsubmit</p>
<h4 id="五、input-标签："><a href="#五、input-标签：" class="headerlink" title="五、input 标签："></a>五、input 标签：</h4><p>作用：让用户输入内容</p>
<p><strong>属性</strong>：</p>
<p>类型 type：决定形式</p>
<ul>
<li><p>text 普通本输入框</p>
</li>
<li><p>color 选择颜色</p>
</li>
<li><p>button 按钮</p>
<p><code>&lt;input type=&quot;button&quot; value=&quot;点击&quot;&gt;</code></p>
<p>可使用 button 标签代替</p>
</li>
<li><p>submit 提交按钮(必须要有，否则提交不了)</p>
<p><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</code></p>
</li>
<li><p>radio 单选框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>checkbox 复选框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;&gt;唱</span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;&gt;跳</span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;&gt;Rap</span><br></pre></td></tr></table></figure></li>
<li><p>password：密码输入框，输入会被遮挡</p>
</li>
<li><p>file：文件选择框，multiple 属性，是否允许选择多个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot;&gt;选择一个文件</span><br><span class="line">&lt;input type&#x3D;&quot;file&quot; multiple&gt;选择多个文件</span><br></pre></td></tr></table></figure></li>
<li><p>hidden：不显示在页面</p>
</li>
</ul>
<p>其他属性：</p>
<ul>
<li><p>name：名称</p>
</li>
<li><p>value：值</p>
</li>
</ul>
<p><strong>事件</strong>：</p>
<p>onchange/onfocus/onblur(失去)</p>
<p><strong>验证器：</strong><br>HTML5 新增功能。required：是否为必填控件。</p>
<h4 id="六、其他输入标签"><a href="#六、其他输入标签" class="headerlink" title="六、其他输入标签"></a>六、其他输入标签</h4><ul>
<li><p>button 标签</p>
<p>生成一个可以点击的按钮，内部不仅放置文字，还可以放置图像</p>
<p>type 属性，按钮的类型：submit（提交）、button（不提交）</p>
</li>
<li><p>textarea 标签：生成多行的文本框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;textarea type&#x3D;&quot;resize：none;width: 50%;height 300px &quot;&gt;</span><br><span class="line">这是一个很长的故事。</span><br><span class="line">&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure>
<p><code>resize：none</code> 输入框无法拖动</p>
</li>
<li><p>select+option 标签：生成下拉菜单</p>
<p>selected 表示默认选择的菜单项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;0&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;1&quot; selected&gt;星期一&lt;&#x2F;option&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;2&quot;&gt;星期二&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>label：控件的文字说明</p>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>一般不监听 input 的 click</li>
<li>form 里面的 input 要有 name</li>
<li>form 里面要放一个 type=submit 才能触发 submit 事件</li>
</ul>
]]></content>
      <tags>
        <tag>布局</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 对象</title>
    <url>/2021/03/09/JS%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="一、常见用法"><a href="#一、常见用法" class="headerlink" title="一、常见用法"></a>一、常见用法</h3><p>变量做属性名</p>
<p>除了字符串之外，变量也可以做属性名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p1 &#x3D; &#39;name&#39;</span><br><span class="line">let obj &#x3D; &#123; p1 : &#39;ss&#39;&#125; 这样写，属性名为 &#39;p1&#39;</span><br><span class="line">let obj &#x3D; &#123; [p1] : &#39;ss&#39; &#125; 这样写，属性名为 &#39;name&#39;</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<p>查看属性值</p>
<ul>
<li><p>中括号：<code>obj[&#39;key&#39;]</code></p>
</li>
<li><p>点语法：<code>obj.key</code></p>
</li>
</ul>
<h3 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h3><ol>
<li><p>Object.assign()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const returnedTarget &#x3D; Object.assign(target, source);</span><br></pre></td></tr></table></figure>
<p>将所有可枚举属性的值从一个或多个源对象分配到目标对象,回目标对象,目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。</p>
</li>
<li><p>Object.entries()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const object1 &#x3D; &#123;</span><br><span class="line"> a: &#39;somestring&#39;,</span><br><span class="line"> b: 42</span><br><span class="line">&#125;;</span><br><span class="line">Object.entries(object1)</span><br><span class="line">&#x2F;&#x2F;[[&quot;a&quot;, &quot;somestring&quot;],[&quot;b&quot;, 42]]</span><br></pre></td></tr></table></figure>
<p>法返回一个给定对象自身可枚举属性的键值对数组</p>
</li>
<li><p>Object.freeze()<br>冻结一个对象。一个被冻结的对象再也不能被修改</p>
</li>
<li><p>Object.is()<br>判断两个值是否为同一个值。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is">MDN</a></p>
</li>
<li><p>Object.keys()<br>返回一个由一个给定对象的自身可枚举属性组成的数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span><br><span class="line">&#x2F;&#x2F;[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]</span><br><span class="line">Object.keys(&#123; 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; &#125;)</span><br><span class="line">&#x2F;&#x2F;[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]</span><br></pre></td></tr></table></figure></li>
<li><p>Object.values()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.values(&#123; foo: &#39;bar&#39;, baz: 42 &#125;)</span><br><span class="line">&#x2F;&#x2F;[&#39;bar&#39;, 42]</span><br></pre></td></tr></table></figure></li>
<li><p>Object.create()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create(&#123;a:1,b:2&#125;);</span><br><span class="line">&#x2F;&#x2F;__proto__:</span><br><span class="line">    a: 1</span><br><span class="line">    b: 2</span><br></pre></td></tr></table></figure>
<p>创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p>
</li>
<li><p>Object.defineProperty()</p>
<p>直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(&#123;&#125;, &#39;a&#39;,&#123;value:1&#125;);  &#x2F;&#x2F;&#123;a:1&#125;</span><br><span class="line">Object.defineProperty(&#123;&#125;, &#39;property1&#39;, &#123;</span><br><span class="line">value: 42,</span><br><span class="line">writable: false   &#x2F;&#x2F;描述符</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>拥有布尔值的键 configurable、enumerable 和 writable 的默认值都是 false。<br>属性值和函数的键 value、get 和 set 字段的默认值为 undefined。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Router</title>
    <url>/2021/03/11/Vue%20router/</url>
    <content><![CDATA[<h5 id="1、Vue-Router"><a href="#1、Vue-Router" class="headerlink" title="1、Vue Router"></a>1、Vue Router</h5><p>Vue.js 官方的路由管理器。路由就是 SPA（single page application 单页应用）的路径管理器，单页面应用的思路是一个 index.html 里面有一个容器，在用户进行交互的时候，并不会重新加载某个界面，而是只选择把某个视图更新到容器中去显示。</p>
 <a id="more"></a>

<h5 id="2、路由模式"><a href="#2、路由模式" class="headerlink" title="2、路由模式"></a>2、路由模式</h5><ul>
<li><p>hash 模式</p>
<p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载。# 是 url 的一个锚点，记载了网页中的位置，Hash 模式通过锚点值的改变，根据不同的值，渲染指定 DOM 位置的不同数据。<br>hash 模式的原理是 onhashchange 事件(监测 hash 值变化)，可以在 window 对象上监听这个事件。</p>
</li>
</ul>
<ul>
<li><p>history 模式</p>
<p>当你使用 history 模式时，URL 就像正常的 url，需要后台配置支持</p>
</li>
</ul>
<h5 id="3、页面跳转"><a href="#3、页面跳转" class="headerlink" title="3、页面跳转"></a>3、页面跳转</h5><ul>
<li><p>声明式：以标签的形式声明为一个跳转的标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单用法</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;传递参数</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;url 传值（index.js设置路由）</span><br><span class="line">&#123;</span><br><span class="line">  path:&#39;&#x2F;user&#x2F;:id&#x2F;&#39;, &#x2F;&#x2F;id就是传递的参数</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取参数</span><br><span class="line">$route.params.key</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用name匹配路由，使用query来传递参数</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name:&#39;xxx&#39;,query: &#123; key:value&#125;&#125;&quot; &gt;跳转Query&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;获取参数</span><br><span class="line">this.$route.query.queryId</span><br></pre></td></tr></table></figure>
<p><strong>param 和 query 的区别</strong></p>
<ul>
<li>使用 params 传参只能用 name 来引入路由，即 push 里面只能是 name:’xxx’,不能是 path:’/xxx’,因为 params 只能用 name 来引入路由，如果这里写成了 path，接收参数页面会是 undefined。</li>
<li>query name 和 path 都支持。query，url 会加上参数信息，而 param url 并不会携带参数信息。</li>
</ul>
</li>
</ul>
<ul>
<li><p>编程式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不带参数</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 带参数 params</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;,params:&#123;key:value&#125;&#125;)</span><br><span class="line">&#x2F;&#x2F;query</span><br><span class="line">this.$router.push(&#123;name:&#39;xxx&#39;,query:&#123;key:value&#125;&#125;)</span><br><span class="line"></span><br><span class="line">this.$router.go(-1)&#x2F;&#x2F;跳转到上一次浏览的页面</span><br><span class="line">this.$router.replace(&#39;&#x2F;menu&#39;)&#x2F;&#x2F;指定跳转的地址</span><br><span class="line">this.$router.replace(&#123;name:&#39;menuLink&#39;&#125;)&#x2F;&#x2F;指定跳转路由的名字下</span><br></pre></td></tr></table></figure>
<p><strong>push 和 replace 的区别：</strong></p>
<ul>
<li>使用 push 方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。也就是说是支持后退的。</li>
</ul>
<ul>
<li>使用 replace 方法不会向 history 添加新记录，而是替换掉当前的 history 记录，即当 replace 跳转到的网页后，’后退’ 按钮不能查看之前的页面。</li>
</ul>
</li>
</ul>
<h5 id="4、导航守卫"><a href="#4、导航守卫" class="headerlink" title="4、导航守卫"></a>4、导航守卫</h5><ol>
<li><p>全局前置守卫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参数</p>
</li>
</ol>
<ul>
<li><p>to 即将要进入的目标 路由对象</p>
</li>
<li><p>from 当前导航正要离开的路由</p>
</li>
<li><p>next 要执行的操作</p>
<ul>
<li>next(): 进行管道中的下一个钩子（放行）。</li>
<li>next(false): 中断当前的导航。</li>
<li>next(‘/‘) 或者 next({ path: ‘/‘ }):跳转到一个不同的地址。</li>
<li>next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>全局解析守卫</p>
<p> router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
</li>
<li><p>全局后置钩子</p>
<p> 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>路由独享的守卫<br> 在路由配置上直接定义 beforeEnter 守卫：<br> 与全局前置守卫的方法参数是一样的。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>组件内的守卫</p>
<ul>
<li>beforeRouteEnter</li>
</ul>
<ul>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  const Foo &#x3D; &#123;</span><br><span class="line">  template: &#96;...&#96;,</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;</span><br><span class="line">    &#x2F;&#x2F; 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，</span><br><span class="line">    &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 导航离开该组件的对应路由时调用</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>beforeRouteEnter 守卫 不能 访问 this,可以通过传一个回调给 next 来访问组件实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 &#96;vm&#96; 访问组件实例</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的导航解析流程</p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">官方文档</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组</title>
    <url>/2021/03/09/JS%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="1、数组对象"><a href="#1、数组对象" class="headerlink" title="1、数组对象:"></a>1、数组对象:</h4><ul>
<li>元素的数据类型可以不同</li>
<li>内存不一定是连续的（对象随机存储）</li>
<li>不能通过数字下标，而是字符串下标<br><code>let arr= [1,2,3] arr[&#39;xxx&#39;]=1</code><a id="more"></a>

</li>
</ul>
<h4 id="2、创建数组"><a href="#2、创建数组" class="headerlink" title="2、创建数组"></a>2、创建数组</h4><ul>
<li><p>新建数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[1,2,3] 简写形式</span><br><span class="line"></span><br><span class="line">let arr&#x3D;new Array(1,2,3) 标准形式</span><br><span class="line"></span><br><span class="line">let arr&#x3D;new Array(3) 一个参数表示数组长度，多个参数表示数字内容</span><br></pre></td></tr></table></figure></li>
<li><p>转化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;&#39;1,2,3&#39;.split(&#39;,&#39;) 以逗号分开创建</span><br><span class="line">let arr&#x3D;&#39;123&#39;.split(&#39;&#39;) 以空字符串分开创建</span><br><span class="line">Array.from(&#39;123&#39;) 很多时候需要有数字下标，和 length</span><br></pre></td></tr></table></figure></li>
<li><p>合并数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr1.concat(arr2)</span><br><span class="line">截取数组的一部分：</span><br><span class="line"></span><br><span class="line">arr1.slice(1) 从第 2 个元素开始</span><br><span class="line">arr1.slice(0) 全部截取（复制数组）</span><br></pre></td></tr></table></figure></li>
<li><p>伪数组：</p>
<p>没有数组共同属性的数组</p>
<p>伪数组的原型链中并没有数组的原型，原型直接指向对象的原型</p>
</li>
</ul>
<h4 id="3、删除数组元素"><a href="#3、删除数组元素" class="headerlink" title="3、删除数组元素"></a>3、删除数组元素</h4><ul>
<li><p>和对象一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</span><br><span class="line">delete arr[0]</span><br><span class="line">arr&#x3D;&gt;[empty,&#39;2&#39;,&#39;3&#39;]</span><br></pre></td></tr></table></figure>
<p>数组长度不会改变（稀疏数组）</p>
</li>
</ul>
<ul>
<li>arr.shift() //arr 被修改，并返回被删除元素</li>
<li>arr.pop()//arr 被修改，并返回被删除元素</li>
<li>arr.splice(start,1) //从 start 位置开始，删除 1 个元素</li>
<li>arr.splice(start,1,’x’)//在删除位置添加’x’</li>
<li>arr.splice(start,1,’x’,’y’)//在删除位置添加’x’,’y’</li>
</ul>
<h4 id="4、查看所有元素"><a href="#4、查看所有元素" class="headerlink" title="4、查看所有元素"></a>4、查看所有元素</h4><ul>
<li><p>查看所有属性名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[1,2,3,4,5];arr.x&#x3D;x</span><br><span class="line">&#x2F;&#x2F;为数组添加 x 下标,值为&#39;x&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>Object,keys(arr1) 查看属性名<br>查看数字（字符串）属性名和值</p>
</li>
<li><p>for 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">console.log(&#96;$&#123;i&#125;:$&#123;arr[i]&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach()</span><br><span class="line"></span><br><span class="line">arr3.forEach(function(iterm,index)&#123;</span><br><span class="line">console.log(&#96;$&#123;index&#125;:$&#123;iterm&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function forEach(array,fn)&#123;</span><br><span class="line">    for(let i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">        fn(array[i],i,array)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>for 循环与 forEach 的区别</p>
<p>for 循环可以随时停止，forEach 不可以<br>for 块级作用域，forEach 是函数</p>
</li>
<li><p>查看单个属性<br>跟对象一样<br><code>let arr=[1,2,3] arr[0]</code></p>
</li>
<li><p>索引越界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr[arr.length]&#x3D;&#x3D;&#x3D;undefined</span><br><span class="line">arr[-1]&#x3D;&#x3D;&#x3D;uddefined</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i &#x3D; 0; i&lt;&#x3D; arr.length; i++)&#123;</span><br><span class="line">console.log(arr[i].toString())</span><br><span class="line">&#125;&#x2F;&#x2F;报错 Cannot read property &#39;toString&#39; of undefined</span><br></pre></td></tr></table></figure></li>
<li><p>查找某个元素是否在数组里</p>
<pre><code>arr.indexof(item)//存在返回索引，否则返回-1</code></pre>
<p>使用条件查找元素</p>
<pre><code>arr.find(x=&gt;x%2===0)//找到第一个偶数</code></pre>
<p>条件查找元素索引</p>
<pre><code>arr.findIndex(x=&gt;x%2===0)//找到第一个偶数索引</code></pre>
</li>
</ul>
<h4 id="5、增加数组中的元素"><a href="#5、增加数组中的元素" class="headerlink" title="5、增加数组中的元素"></a>5、增加数组中的元素</h4><ul>
<li><p>对象的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr&#x3D;[1,2,3,4,5]</span><br><span class="line">arr[5]&#x3D;6 &#x2F;&#x2F;可以修改成功，但不推荐，数组下标如果写大了，会出问题</span><br></pre></td></tr></table></figure></li>
<li><p>在尾部增加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.push(item1,item2...)&#x2F;&#x2F;修改 arr，返回新长度</span><br></pre></td></tr></table></figure></li>
<li><p>在头部增加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.unshift(item1,item2...)&#x2F;&#x2F;修改 arr，返回新长度</span><br></pre></td></tr></table></figure></li>
<li><p>在中间添加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.splice(start,0,&#39;x&#39;,&#39;y&#39;...)</span><br></pre></td></tr></table></figure>
<h4 id="6、修改数组中的元素"><a href="#6、修改数组中的元素" class="headerlink" title="6、修改数组中的元素"></a>6、修改数组中的元素</h4></li>
<li><p>反转顺序</p>
<pre><code>arr.reverse()//修改原数组</code></pre>
<p>例：将字符串反转’12345’</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;12345&#39;.split(&#39;&#39;).reverse().join(&#39;&#39;) &#x2F;&#x2F; 54321</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>自定义顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.sort((a,b)&#x3D;&gt;a-b)&#x2F;&#x2F;函数返回值小于 0，即 a-b&lt;0,a 排在 b 之前。</span><br></pre></td></tr></table></figure></li>
<li><p>按照某个属性排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; [</span><br><span class="line">    &#123; name: &#39;Edward&#39;, value: 21 &#125;,</span><br><span class="line">    &#123; name: &#39;Sharpe&#39;, value: 37 &#125;,</span><br><span class="line">    &#123; name: &#39;And&#39;, value: 45 &#125;,</span><br><span class="line">    &#123; name: &#39;The&#39;, value: -12 &#125;,</span><br><span class="line">    &#123; name: &#39;Zeros&#39;, value: 37 &#125;</span><br><span class="line">]</span><br><span class="line">items.sort((a,b)&#x3D;&gt;a.value-b.value) &#x2F;&#x2F;以 value 值排序</span><br></pre></td></tr></table></figure></li>
<li><p>map</p>
<p>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.map(x &#x3D;&gt; x \* x) &#x2F;&#x2F;每个元素的平方</span><br></pre></td></tr></table></figure></li>
<li><p>filter</p>
<p>创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 true 为通过，false 不通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrary.filter(x&#x3D;&gt;x%2&#x3D;&#x3D;&#x3D;1)&#x2F;&#x2F;除以 2 余 1 就保留</span><br></pre></td></tr></table></figure></li>
<li><p>reduce（重点）</p>
<p>对数组中的每个元素执行一个由您提供的函数 Arrayarray，将其结果汇总为单个返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.reduce((sum,x)&#x3D;&gt;sum+x,0)&#x2F;&#x2F;计算数组铬元素之和</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce((x,y)&#x3D;&gt;&#123;</span><br><span class="line">    if(y%2&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">        return x.concat(y)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[]) &#x2F;&#x2F;把 arr 中所有偶数汇总为一个新的数组</span><br><span class="line">可以改写为</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce((x,y)&#x3D;&gt;&#123;</span><br><span class="line">    return x.concat(y%2&#x3D;&#x3D;&#x3D;0?y:[])</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure></li>
<li><p><strong>例子</strong>:数据变换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">&#123; 名称: &quot;动物 &quot;, id: 1, parent: null &#125;,</span><br><span class="line">&#123; 名称: &quot;狗&quot;, id: 2, parent: 1 &#125;,</span><br><span class="line">&#123; 名称: &quot;猫&quot;, id: 3, parent: 1 &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>将数组变成对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">id: 1, : 名称&#39;动物 &#39;, children: [</span><br><span class="line">    &#123;id: 2, 名称: &#39;狗 &#39;, children: null&#125;,</span><br><span class="line">    &#123;id: 3, 名称: &#39; 猫&#39;, children: null&#125;,</span><br><span class="line">] &#125;</span><br><span class="line">&#x2F;&#x2F;&#96;&#96;代码如下：</span><br><span class="line">arr.reduce(</span><br><span class="line">(result, item) &#x3D;&gt; &#123;</span><br><span class="line">    if (item.parent &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    result.id &#x3D; item.id</span><br><span class="line">    result[&quot;名称&quot;] &#x3D; item[&quot;名称&quot;]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    result.children.push(item)</span><br><span class="line">    delete item.parent</span><br><span class="line">    item.children &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;,</span><br><span class="line">&#123; id: null, children: [] &#125; &#x2F;&#x2F;初始化id、children</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3的一些新特性和一些问题</title>
    <url>/2021/03/11/Vue3/</url>
    <content><![CDATA[<p>1、Vue3 和 Vue2 的一些区别</p>
<ul>
<li>创建实例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue3 新方法 createApp 其作用是构建实例</span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">const app &#x3D; createApp(&#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; Vue2 使用的是 new Vue() 构建实例</span><br></pre></td></tr></table></figure>
<ul>
<li>Vue3 支持碎片(Fragments)，就是说在组件可以拥有多个根节点</li>
</ul>
<a id="more"></a>

<p>3、组合式 api</p>
<ul>
<li><p>setup 组件选项</p>
<ul>
<li><p>在创建组件之前执行，一旦 props 被解析，就作为组合式 API 的入口。接受两个参数 props 和 context</p>
</li>
<li><p>props:响应式的，当传入新的 prop 时，它将被更新。</p>
<p>不能使用 ES6 解构，因为它会消除 prop 的响应性，需要解构 prop，可以通过使用 setup 函数中的 toRefs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; toRefs &#125; from &#39;vue&#39;</span><br><span class="line">setup(props) &#123;</span><br><span class="line">const &#123; title &#125; &#x3D; toRefs(props)</span><br><span class="line">    console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>Context:context 是一个普通的 JavaScript 对象，它暴露三个组件的 property</p>
<pre><code>export default &#123;
 setup(props, context) &#123;
      // Attribute (非响应式对象)
      console.log(context.attrs)
     // 插槽 (非响应式对象)
     console.log(context.slots)
     // 触发事件 (方法)
     console.log(context.emit)
 &#125;
&#125;
//可以使用es6解构
export default &#123;
  setup(props, &#123; attrs, slots, emit &#125;) &#123;
  ...
  &#125;
&#125;</code></pre>
</li>
<li><p>执行 setup 时，组件实例尚未被创建，将无法访问组件选项：data、computed、methods</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>带 ref 的响应式变量</p>
<p>接受参数，并将其包裹在一个带有 value property 的对象中返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">const counter &#x3D; ref(0)</span><br><span class="line">console.log(counter) &#x2F;&#x2F; &#123; value: 0 &#125;</span><br><span class="line">console.log(counter.value) &#x2F;&#x2F; 读</span><br><span class="line">counter.value++     &#x2F;&#x2F;写</span><br></pre></td></tr></table></figure></li>
<li><p>在 setup()中 methods、computed、watch、生命周期函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; computed, ref, onMounted,  watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">props: &#123;</span><br><span class="line">  title: String</span><br><span class="line">&#125;,</span><br><span class="line">setup (props, context) &#123;</span><br><span class="line">  const counter &#x3D; ref(0)</span><br><span class="line">  const &#123; user &#125; &#x3D; toRefs(props)</span><br><span class="line">  const add1&#x3D;()&#x3D;&gt;&#123;  &#x2F;&#x2F; context.emit代替this.$emit</span><br><span class="line">    context.emit(&#39;x&#39;,counter.value+1</span><br><span class="line">  &#125;</span><br><span class="line">  const add2 &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">    return counter.value+2</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(add1)</span><br><span class="line">  watch(user, add1)   &#x2F;&#x2F;return 之后才能在模板中使用</span><br><span class="line">  return &#123;counter,add1,add2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Teleport:允许我们控制在 DOM 中哪个父节点下呈现 HTML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;teleport&gt;  &#x2F;&#x2F;将 div放在body里面</span><br></pre></td></tr></table></figure>
<p>4、属性绑定</p>
</li>
</ul>
<p>默认所有属性都绑定到根元素</p>
<p>//<strong>Button.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot &#x2F;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p>//<strong>ButtonDemo.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;button 内容&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;h1&gt;示例&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;Button @click&#x3D;&quot;&quot; @focus&#x3D;&quot;&quot;&gt;按钮&lt;&#x2F;Button&gt; &#x2F;&#x2F;Button上所有时间属性</span><br><span class="line">  会绑定到Button组件跟元素上</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Button from &quot;..&#x2F;lib&#x2F;Button.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; Button &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>inheritAttrs:false</code>可以取消默认绑定</li>
<li>使用<code>$attrs</code>或者 <code>context.attrs</code> 获取所有属性</li>
<li>使用 <code>v-bind=&#39;$attrs&#39;</code>批量绑定属性</li>
<li>使用<code>const &#123;size,onclick,...xxx&#125;=context.attrs</code>将属性分开</li>
</ul>
<p>props 和 attrs 的区别</p>
<ul>
<li>props 要先声明才能取值，attrs 不需要</li>
<li>props 不包含事件，attrs 包含</li>
<li>props 没有声明的属性，会跑到 attrs 里</li>
<li>props 支持 String 之外的类型，attrs 只支持 String 类型</li>
</ul>
<p>5、context.slots.default()</p>
<p><strong>检查组件内部标签类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup(props, context) &#123;</span><br><span class="line">  const defaults &#x3D; context.slots.default();</span><br><span class="line">  defaults.forEach((tag) &#x3D;&gt; &#123;</span><br><span class="line">     if (tag.type !&#x3D;&#x3D; Tab) &#123;</span><br><span class="line">       throw new Error(&quot;Tabs子标签必须是Tab标签);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>6、Vue3 支持 TS 和 markdown</p>
<p>支持 TS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;shims.vue.d.ts</span><br><span class="line">declare module &quot;*.vue&quot; &#123;</span><br><span class="line">import &#123; ComponentOptions &#125; from &quot;vue&quot;;</span><br><span class="line">const componentOptions: ComponentOptions;</span><br><span class="line">export default componentOptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持 markdown</p>
<p>//shims.vue.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &quot;*.md&quot; &#123;</span><br><span class="line">  const str: string;</span><br><span class="line">  export default str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin/md.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; @ts-nocheck</span><br><span class="line">import path from &quot;path&quot;;</span><br><span class="line">import fs from &quot;fs&quot;;</span><br><span class="line">import marked from &quot;marked&quot;;</span><br><span class="line"></span><br><span class="line">const mdToJs &#x3D; (str) &#x3D;&gt; &#123;</span><br><span class="line">  const content &#x3D; JSON.stringify(marked(str));</span><br><span class="line">  return &#96;export default $&#123;content&#125;&#96;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export function md() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    configureServer: [</span><br><span class="line">      &#x2F;&#x2F; 用于开发</span><br><span class="line">      async (&#123; app &#125;) &#x3D;&gt; &#123;</span><br><span class="line">        app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">          if (ctx.path.endsWith(&quot;.md&quot;)) &#123;</span><br><span class="line">            ctx.type &#x3D; &quot;js&quot;;</span><br><span class="line">            const filePath &#x3D; path.join(process.cwd(), ctx.path);</span><br><span class="line">            ctx.body &#x3D; mdToJs(fs.readFileSync(filePath).toString());</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            await next();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    transforms: [</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F; 用于 rollup</span><br><span class="line">        test: (context) &#x3D;&gt; context.path.endsWith(&quot;.md&quot;),</span><br><span class="line">        transform: (&#123; code &#125;) &#x3D;&gt; mdToJs(code),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的基本用法</title>
    <url>/2021/03/11/Vuex/</url>
    <content><![CDATA[<h5 id="1、Vuex-是什么？"><a href="#1、Vuex-是什么？" class="headerlink" title="1、Vuex 是什么？"></a>1、Vuex 是什么？</h5><p>一个专为 Vue.js 应用程序开发的状态管理工具</p>
<h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><ul>
<li>解耦：将所有数据相关的逻辑放入 store（也就是 MVC 中的 Model，换了个名字而已）</li>
<li>数据读写更方便：任何组件不管在哪里，都可以直接读写数据</li>
<li>控制力更强：组件对数据的读写只能使用 store 提供的 API 进行<a id="more"></a>

</li>
</ul>
<h5 id="3、核心概念"><a href="#3、核心概念" class="headerlink" title="3、核心概念"></a>3、核心概念</h5><p>Vuex 的核心就是仓库 store，这个 store 实例会被注入到所有子组件里面,子组件通过<code>this.$store</code>获取</p>
<p>主要架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>state</p>
<p>state 属性保存着全局的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  count: 10   &#x2F;&#x2F;定义状态</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件通过计算属性获取</span><br><span class="line">computed: &#123;</span><br><span class="line">  count() &#123;</span><br><span class="line">    return this.$store.state.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapState：辅助函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">computed: mapState(&#123;</span><br><span class="line">    count: state &#x3D;&gt; state.count,</span><br><span class="line">    &#x2F;&#x2F; 传字符串参数 &#39;count&#39; 等同于 &#96;state &#x3D;&gt; state.count&#96;</span><br><span class="line">    countAlias: &#39;count&#39;,</span><br><span class="line">    &#x2F;&#x2F; 为了能够使用 &#96;this&#96; 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象三点操作符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  computed: &#123;</span><br><span class="line">    msg() &#123;</span><br><span class="line">      return this.$store.state.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">  ...mapState([&#39;count&#39;, &#39;firstName&#39;, &#39;lastName&#39;])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>Getter</p>
<p>对状态进行处理的提取出来的公共部分,可以理解为 state 的计算属性，结果会缓存，且只有当它的依赖值发生了改变才会被重新计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">  list: [1, 2, 3, 4, 5]</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">  modifyArr(state) &#123;</span><br><span class="line">    return state.list.filter((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">      return item % 2 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getLength(state, getter) &#123; &#x2F;&#x2F; 方法里面传getter，调用modifyArr来计算长度</span><br><span class="line">    return getter.modifyArr.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>mapGetters:辅助函数,将 store 中的 getter 映射到局部计算属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">&#x2F;&#x2F; 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    &#39;modifyArr&#39;,</span><br><span class="line">    &#39;getLength&#39;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;改名</span><br><span class="line">  computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    x:&#39;modifyArr&#39;,</span><br><span class="line">    y:&#39;getLength&#39;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mutation</p>
<ul>
<li><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变更状态</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(&#39;increment&#39;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;提交额外参数</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state,n) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变更状态</span><br><span class="line">    state.count+&#x3D; n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(&#39;increment&#39;,1)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>对象风格的提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: &#39;increment&#39;,</span><br><span class="line">  n: 10</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, obj) &#123;</span><br><span class="line">    state.count +&#x3D; obj.n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapMutations:辅助函数</p>
<p>官方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;mapMutations&#125; from &#39;vuex&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations([</span><br><span class="line">    &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：</span><br><span class="line">    &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;</span><br><span class="line">  ]),</span><br><span class="line">  ...mapMutations(&#123;</span><br><span class="line">    add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Action</p>
<p>Action 类似于 mutation，不同在于：</p>
<p>Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   actions: &#123;</span><br><span class="line">  increment (context) &#123; &#x2F;&#x2F;context是和store 实例具有相同方法和属性的对象</span><br><span class="line">    context.commit(&#39;increment&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）</p>
<p><a href="https://vuex.vuejs.org/zh/guide/actions.html">文档</a></p>
</li>
<li><p>Module</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const moduleA &#x3D; &#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>
<p><a href="https://vuex.vuejs.org/zh/guide/modules.html">官方文档</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域 CORS和JSON</title>
    <url>/2021/03/09/ajax/</url>
    <content><![CDATA[<ol>
<li>概述</li>
</ol>
<p>AJAX：Asynchronous JavaScript + XML（）</p>
<ul>
<li>AJAX 是浏览器上的功能，浏览器可以发请求，收响应</li>
<li>浏览器在 window 上加了一个 XMLHttpRequest 函数</li>
</ul>
<ul>
<li>用这个构造函数（类）可以构造出一个对象<br>JS 通过它实现发请求，收响应<a id="more"></a>
</li>
</ul>
<ol start="2">
<li>使用</li>
</ol>
<ul>
<li>JS 代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const request &#x3D; new XMLHttpRequest()</span><br><span class="line">request.open(&quot;GET&quot;, &quot;&#x2F;style.css&quot;)</span><br><span class="line">request.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(request.readyState)</span><br><span class="line">    if (request.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if (request.status &gt;&#x3D; 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">             console.log(&quot;下载完成了&quot;)</span><br><span class="line">            const style &#x3D; document.createElement(&quot;style&quot;)</span><br><span class="line">            style.innerHTML &#x3D; request.response</span><br><span class="line">             document.head.appendChild(style)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;加载 css 失败&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>服务端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;server.js</span><br><span class="line">var http &#x3D; require(&quot;http&quot;)</span><br><span class="line">var fs &#x3D; require(&quot;fs&quot;)</span><br><span class="line">var url &#x3D; require(&quot;url&quot;)</span><br><span class="line">var port &#x3D; process.argv[2]</span><br><span class="line"></span><br><span class="line">if (!port) &#123;</span><br><span class="line">console.log(&quot;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&quot;)</span><br><span class="line">process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server &#x3D; http.createServer(function (request, response) &#123;</span><br><span class="line">var parsedUrl &#x3D; url.parse(request.url, true)</span><br><span class="line">var pathWithQuery &#x3D; request.url</span><br><span class="line">var queryString &#x3D; &quot;&quot;</span><br><span class="line">if (pathWithQuery.indexOf(&quot;?&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">    queryString &#x3D; pathWithQuery.substring(pathWithQuery.indexOf(&quot;?&quot;))</span><br><span class="line">&#125;</span><br><span class="line">var path &#x3D; parsedUrl.pathname</span><br><span class="line">var query &#x3D; parsedUrl.query</span><br><span class="line">var method &#x3D; request.method</span><br><span class="line"></span><br><span class="line">console.log(&quot;有个傻子发请求过来啦！路径（带查询参数）为：&quot; + pathWithQuery)</span><br><span class="line"></span><br><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;index.html&quot;) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html;charset&#x3D;utf-8&quot;)</span><br><span class="line">    let string &#x3D; fs.readFileSync(&quot;public&#x2F;index.html&quot;).toString()</span><br><span class="line">    const page1 &#x3D; fs.readFileSync(&quot;db&#x2F;page1.json&quot;).toString()</span><br><span class="line">    const array &#x3D; JSON.parse(page1)</span><br><span class="line">    const result &#x3D; array.map((item) &#x3D;&gt; &#96;&lt;li&gt;$&#123;item.id&#125;&lt;&#x2F;li&gt;&#96;).join(&quot;&quot;)</span><br><span class="line">    string &#x3D; string.replace(&quot;&#123;&#123;page1&#125;&#125;&quot;, &#96;&lt;ul id&#x3D;&quot;aa&quot;&gt;$&#123;result&#125;&lt;&#x2F;ul&gt;&#96;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    response.statusCode &#x3D; 404</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;css;charset&#x3D;utf-8&quot;)</span><br><span class="line">    response.write(&#96;你访问的页面不存在&#96;)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(</span><br><span class="line">&quot;监听 &quot; +</span><br><span class="line">    port +</span><br><span class="line">    &quot; 成功\n请用在空中转体720度然后用电饭煲打开 http:&#x2F;&#x2F;localhost:&quot; +</span><br><span class="line">    port</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas</title>
    <url>/2021/03/09/canvas/</url>
    <content><![CDATA[<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><p><code>&lt;canvas&gt;</code>元素可被用来通过 JS 绘制图形动画</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>canvas 标签 （自带宽高属性）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&#39;canvas&#39; width:&quot;100&quot; height:&quot;100&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>JS</p>
<p>创建 canvas 画布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br><span class="line">let ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br></pre></td></tr></table></figure></li>
<li><p>常用属性</p>
</li>
</ol>
<ul>
<li><p>绘制矩形:</p>
<ul>
<li>填充：fillRect(x,y,width,height)</li>
<li>边框：strokeRect</li>
<li>清除指定矩形区域 <code>clearRect(x, y, width, height)</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式原理</title>
    <url>/2021/03/11/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h4><p><strong><code>Vue</code>会遍历<code>data</code>对象的所有<code>property</code>，并使用<code>Object.defineProperty</code>把这些<code>property</code>全部转为<code>getter/setter</code>。通过<code>getter/setter</code>让 Vue 能够追踪依赖，在<code>property</code>被访问和修改时通知变更。</strong></p>
 <a id="more"></a>

<h4 id="二、Object-defineProperty-和-getter、setter"><a href="#二、Object-defineProperty-和-getter、setter" class="headerlink" title="二、Object.defineProperty 和 getter、setter"></a>二、Object.defineProperty 和 getter、setter</h4><p><code>Object.defineProperty</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let data1 &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(data1, &quot;n&quot;, &#123;</span><br><span class="line">  value: 0</span><br><span class="line">&#125;);</span><br><span class="line">console.log(data1.n);  &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>
<br>

<p><code>getter/setter</code>用于对属性的读写进行监控</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myData2 &#x3D; &#123; n: 0 &#125;;</span><br><span class="line">let data2 &#x3D; proxy(&#123; data: myData2 &#125;); &#x2F;&#x2F; 括号里是匿名对象，无法访问</span><br><span class="line"></span><br><span class="line">function proxy(&#123; data &#125;) &#123;</span><br><span class="line">  let value &#x3D; data.n;</span><br><span class="line">  Object.defineProperty(data, &quot;n&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">      if (newValue &lt; 0) return;</span><br><span class="line">      value &#x3D; newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F;监听 data</span><br><span class="line"></span><br><span class="line">  const obj &#x3D; &#123;&#125;;</span><br><span class="line">  Object.defineProperty(obj, &quot;n&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return data.n;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">     if (newValue &lt; 0) return;</span><br><span class="line">      data.n &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return obj; &#x2F;&#x2F; obj 就是代理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(data2.n);	&#x2F;&#x2F;0</span><br><span class="line">myData2.n &#x3D; -1;</span><br><span class="line">console.log(data2.n);	&#x2F;&#x2F;0</span><br><span class="line">myData2.n &#x3D; 1;</span><br><span class="line">console.log(data2.n);	&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<br>

<p><strong>当<code>let vm=new Vue(&#123;data:myData&#125;)</code>时，会让 vm 成为 Vue 的代理，对 myData 的所有属性进行监控，使得 myData 的属性变化的时候渲染页面。</strong></p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p><strong>Vue 的数据响应式，是通过<code>Object.defineProperty</code>将对象所有的属性转化为<code>getter/setter</code>来监控数据变化，即时渲染页面。</strong></p>
<p><strong>注意</strong>：Vue 不能检测到对象属性的添加或删除，解决方法是手动调用 Vue.set 或者 this.$set<br><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">文档</a></p>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack简单配置</title>
    <url>/2021/03/11/webpack/</url>
    <content><![CDATA[<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>Webpack 是一个模块打包工具(module bundler)，其最主要的功能就是模块打包，模块打包，通俗地说就是：找出模块之间的依赖关系，按照一定的规则把这些模块组织合并为一个 JavaScript 文件。Webpack 认为一切都是模块，JS 文件、CSS 文件、jpg/png 图片等等都是模块。</p>
<a id="more"></a>

<h4 id="2、-安装"><a href="#2、-安装" class="headerlink" title="2、 安装"></a>2、 安装</h4><ul>
<li><p>新建项目目录</p>
</li>
<li><p>在目录运行<code>npm init -y</code>,初始化 npm</p>
</li>
<li><p>安装 webpack<code>npm install webpack webpack-cli --save-dev</code></p>
</li>
</ul>
<h4 id="3、mode-模式"><a href="#3、mode-模式" class="headerlink" title="3、mode(模式)"></a>3、mode(模式)</h4><p>development（开发模式）和 production（生产模式）</p>
<ul>
<li>在开发环境中，SourceMap 更全，可以快速定位代码的问题</li>
</ul>
<ul>
<li>在开发环境中，代码一般不需要压缩；生产环境，代码会被压缩</li>
</ul>
<p>webpack-dev-server：能够用于快速开发应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const base &#x3D; require(&quot;.&#x2F;webpack.config.base.js&quot;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...base,</span><br><span class="line">  mode: &quot;development&quot;,</span><br><span class="line">  devtool: &quot;inline-source-map&quot;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;.&#x2F;dist&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用不同的webpack配置文件</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server&quot;,&#x2F;&#x2F;使用默认的</span><br><span class="line">    &quot;build&quot;: &quot;rm -rf dist &amp;&amp; webpack --config webpack.config.prod.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p><strong>webpack-merge</strong></p>
<h4 id="4、-入口和出口"><a href="#4、-入口和出口" class="headerlink" title="4、 入口和出口"></a>4、 入口和出口</h4><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>output 属性告诉 webpack 在哪里输出它所创建的文件，以及如何命名这些文件，默认值为 <code>./dist</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;),   &#x2F;&#x2F;默认值</span><br><span class="line">    filename: &#39;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5、-浏览器缓存和-hash"><a href="#5、-浏览器缓存和-hash" class="headerlink" title="5、 浏览器缓存和 hash"></a>5、 浏览器缓存和 hash</h4><ul>
<li>浏览器缓存：<ul>
<li>当浏览器访问一个 html 页面时，html 页面会加载 JS、CSS 和图片等外部资源，这需要花费一定的下载时间。由于很多资源是长时间不变的，因此可以把这些资源存储在本地，这样就不需要花时间下载。</li>
<li>可以通过响应头，<code>cache-control</code>设置缓存时间</li>
<li>如果文件变化了，可以设置一个新的文件名，这样在请求的时候浏览器就知道文件改变了，而请求新的文件</li>
<li>只要内容不变，就文件名可以一直使用</li>
</ul>
</li>
</ul>
<ul>
<li><p>Webpack 与 hash 算法</p>
<ul>
<li><p>在使用 Webpack 对构建的时候，Webpack 会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack 就会计算出一个新的特殊字符串。</p>
</li>
<li><p>hash/chunkhash/contenthash:<br>hash 所有文件哈希值相同； chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值； contenthash 计算与文件内容本身相关.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &quot;[name].[contenthash].js&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a href="https://webpack.docschina.org/configuration/output/#template-strings">可替换的内容</a></p>
</li>
</ul>
</li>
</ul>
<h4 id="6、loader-和-plugin"><a href="#6、loader-和-plugin" class="headerlink" title="6、loader 和 plugin"></a>6、loader 和 plugin</h4><h5 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h5><ul>
<li><p>babel-loader<br>主要作用是在 Webpack 打包的时候，用 Babel 将 ES6 的代码转换成 ES5 版本的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">   &#123;</span><br><span class="line">     test: &#x2F;\.js$&#x2F;,</span><br><span class="line">     exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">     use: &#123;</span><br><span class="line">       loader: &#39;babel-loader&#39;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>加载 CSS 文件<br>使用 style-loader 和 css-loader 这两个 loader 来处理 CSS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">    use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure>
<p>SCSS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">   use: [</span><br><span class="line">     &quot;style-loader&quot;,</span><br><span class="line">     &quot;css-loader&quot;,</span><br><span class="line">     &#123;</span><br><span class="line">       loader: &quot;sass-loader&quot;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         implementation: require(&quot;dart-sass&quot;),   &#x2F;&#x2F;使用dart-sass 代替 node-sass</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>其他</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.styl$&#x2F;,</span><br><span class="line">  use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.less$&#x2F;,</span><br><span class="line">  use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>css-loader 的作用是解析 CSS 文件，包括解析@import 等 CSS 自身的语法。把 CSS 文件解析后，以字符串的形式打包到 JS 文件中。</li>
<li>style-loader 就来发挥作用了，它可以把 JS 里的样式代码插入到 html 文件里。它的原理很简单，就是通过 JS 动态生成 style 标签插入到 html 文件的 head 标签里。</li>
</ul>
</li>
</ul>
<h5 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h5><ul>
<li>HtmlWebpackPlugin<br>生成 HTML5 文件，使用 script 标签将您的所有捆绑包包括在内。<br><a href="https://github.com/jantimon/html-webpack-plugin#configuration">html-webpack-plugin</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    &#x2F;&#x2F;设置标题</span><br><span class="line">    title: &quot;标题&quot;,</span><br><span class="line">    &#x2F;&#x2F;模板文件路径</span><br><span class="line">    template: &quot;src&#x2F;assets&#x2F;index.html&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>MiniCssExtractPlugin</p>
<p>将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">plugins: [new MiniCssExtractPlugin()],</span><br><span class="line">module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">      test: &#x2F;\.css$&#x2F;i,</span><br><span class="line">      use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;],</span><br><span class="line">      &#125;,</span><br><span class="line">   ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7、loader-和-plugin-的区别"><a href="#7、loader-和-plugin-的区别" class="headerlink" title="7、loader 和 plugin 的区别"></a>7、loader 和 plugin 的区别</h4><p>loader，它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。例:babel-loader 将 JS 文件转换为浏览器可以识别的更低版本的 JS</p>
<p>plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。例：MiniCssExtractPlugin 可以将 CSS 抽离成一个文件</p>
<h4 id="8、webpack-懒加载"><a href="#8、webpack-懒加载" class="headerlink" title="8、webpack 懒加载"></a>8、webpack 懒加载</h4><p>在用户执行某些操作的时候，再加载某些模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;lazy.js</span><br><span class="line">export default function fn() &#123;</span><br><span class="line">console.log(&quot;懒加载&quot;)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> button.onclick &#x3D; e &#x3D;&gt; import(.&#x2F;lazy.js&#39;).then(module &#x3D;&gt; &#123;</span><br><span class="line">   let fn &#x3D; module.default;</span><br><span class="line">   fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2021/03/10/jQuery/</url>
    <content><![CDATA[<p>jQuery 是一个轻量级的 JavaScript 函数库。<br>它的基本设计思想和主要用法，就是”<strong>选择某个网页元素，然后对其进行某种操作</strong>“。<br><br></p>
<a id="more"></a>

<h3 id="jQuery-如何获取元素"><a href="#jQuery-如何获取元素" class="headerlink" title="jQuery 如何获取元素"></a>jQuery 如何获取元素</h3><p>使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），然后得到被选中的元素<br><br><br><strong>选择表达式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document) &#x2F;&#x2F;选择整个文档对象</span><br><span class="line">$(&#39;#myId&#39;) &#x2F;&#x2F;选择ID为myId的网页元素</span><br><span class="line">$(&#39;div.myClass&#39;) &#x2F;&#x2F; 选择class为myClass的div元素</span><br><span class="line">$(&#39;a:first&#39;) &#x2F;&#x2F;选择网页中第一个a元素</span><br><span class="line">$(&#39;tr:odd&#39;) &#x2F;&#x2F;选择表格的奇数行</span><br><span class="line">$(&#39;#myForm :input&#39;) &#x2F;&#x2F; 选择表单中的input元素</span><br></pre></td></tr></table></figure>
<p>对结果进行筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;div&#39;).has(&#39;p&#39;); &#x2F;&#x2F; 选择包含p元素的div元素</span><br><span class="line">$(&#39;div&#39;).not(&#39;.myClass&#39;); &#x2F;&#x2F;选择class不等于myClass的div元素</span><br><span class="line">$(&#39;div&#39;).filter(&#39;.myClass&#39;); &#x2F;&#x2F;选择class等于myClass的div元素</span><br></pre></td></tr></table></figure>
<h3 id="jQuery-的链式操作"><a href="#jQuery-的链式操作" class="headerlink" title="jQuery 的链式操作"></a>jQuery 的链式操作</h3><p>选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;)</span><br></pre></td></tr></table></figure>
<p>原理就是，每一步的 jQuery 操作，返回的都是一个 jQuery 对象<br><br><br>jQuery 提供 end()方法,返回上一次操作的结果</p>
<h3 id="jQuery-如何创建元素"><a href="#jQuery-如何创建元素" class="headerlink" title="jQuery 如何创建元素"></a>jQuery 如何创建元素</h3><p>创建新元素只需要把新元素直接传入 jQuery 的构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;&lt;p&gt;Hello&lt;&#x2F;p&gt;&#39;);</span><br><span class="line">$(&#39;&lt;li class&#x3D;&quot;new&quot;&gt;new list item&lt;&#x2F;li&gt;&#39;);</span><br><span class="line">$(&#39;ul&#39;).append(&#39;&lt;li&gt;list item&lt;&#x2F;li&gt;&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="jQuery-移动元素"><a href="#jQuery-移动元素" class="headerlink" title="jQuery 移动元素"></a>jQuery 移动元素</h3><p>一个方法是直接移动该元素，另一个方法是移动其他元素，使得目标元素达到我们想要的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;div&#39;).insertAfter($(&#39;p&#39;));  &#x2F;&#x2F;把div元素移动p元素后面,返回div元素</span><br><span class="line">$(&#39;p&#39;).after($(&#39;div&#39;));  &#x2F;&#x2F;把p元素加到div元素前面，返回p元素</span><br></pre></td></tr></table></figure>
<h3 id="jQuery-修改元素属性"><a href="#jQuery-修改元素属性" class="headerlink" title="jQuery 修改元素属性"></a>jQuery 修改元素属性</h3><p>jQuery attr() 方法用于获取或修改元素属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#id&quot;).attr(&quot;href&quot;,&quot;http:&#x2F;&#x2F;www.xxx.com&quot;);</span><br><span class="line">$(&quot;#runoob&quot;).attr(&#123;</span><br><span class="line">     &quot;href&quot; : &quot;www.xxx.com&quot;,</span><br><span class="line">     &quot;title&quot; : &quot;jQuery&quot;</span><br><span class="line">&#125;); &#x2F;&#x2F;同时设置多个属性</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DOM</tag>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令行</title>
    <url>/2021/03/09/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.linuxeden.com%2Fwp-content%2Fuploads%2F2017%2F07%2Fbgnu6ymb2jmqy5o01200.jpg&refer=http%3A%2F%2Fwww.linuxeden.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1617944609&t=0f849011a818a10c06e11636a6d92a48"></p>
 <a id="more"></a>

<h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><p>查看目录绝对路径：pwd</p>
<p>查看当前目录内容：ls</p>
<p>查看指定目录内容：ls+路径</p>
<p>查看文件内容：</p>
<p>cat 路径：全部内容</p>
<p>head 路径：前面 10 行，head 路径 -n 14（行数）</p>
<p>tail 路径：后面 10 行，tail 路径 -n 14（行数）</p>
<p>less 路径：分页查看 j、k</p>
<h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><p>创建文件：</p>
<ul>
<li><code>touch</code>： a 创建一个空文件 多个文件空格隔开</li>
<li><code>echo： echo &#39;hi&#39; &gt; 1.txt</code> （覆盖） “&gt;&gt;”表示添加内容 <code>echo -e &#39;1/n2&#39; &gt;&gt;1.txt</code> 添加多行</li>
</ul>
<p>创建目录：</p>
<ul>
<li><p><code>mkdir a/</code></p>
</li>
<li><p>mkdir <code>-p a/b/c/d/e</code>(多层目录) 多个目录 空格隔开</p>
</li>
<li><p>复制文件：<code>cp 1.txt 2.txt</code> 将 1.txt 的内容复制给 2.txt</p>
</li>
<li><p>复制目录：<code>cp -r a b</code> 将 a 目录里的内容复制给 b 目录 -r：递归、重现</p>
</li>
</ul>
<h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><p><code>rm 1.txt</code> 删除文件</p>
<p><code>rm -r a</code> 删除目录</p>
<h4 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h4><p>追加、修改内容：<code>echo &#39;1&#39;&gt;&gt;1.txt</code></p>
<p>打开文件修改：<code>code 1.txt start 1.txt</code></p>
<p>清空内容：<code>echo &quot;&quot;&gt;1.txt</code> 空内容代替文档内容 打开文件删除</p>
<p>修改文件名/目录：<code>mv 1.txt 2.txt</code>mv：移动</p>
<p>重命名文件名/目录：同上</p>
<p>修改文件最后更新时间：<code>touch 1.txt</code></p>
<h3 id="命令的组合："><a href="#命令的组合：" class="headerlink" title="命令的组合："></a>命令的组合：</h3><p>命令成功：没有提示，返回 0</p>
<p>命令失败：提示 error，返回非 0</p>
<p><code>&amp;&amp;</code>命令：当第一条命令成功之后执行下一条命令</p>
<p><code>;</code>命令：不管第一条命令是否成功，都执行下一条</p>
<h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><p>1.创建任意后缀文件</p>
<ol start="2">
<li>添加可执行性权限：chmod +x ./文件名</li>
<li>文件里写命令</li>
<li><code>sh</code>执行</li>
<li><code>shebang #!/usr/bin/env</code> sh</li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>封装DOM</title>
    <url>/2021/03/09/%E5%B0%81%E8%A3%85DOM/</url>
    <content><![CDATA[<h3 id="封装-DOM-操作，对象风格"><a href="#封装-DOM-操作，对象风格" class="headerlink" title="封装 DOM 操作，对象风格"></a>封装 DOM 操作，对象风格</h3><h4 id="一、增加-和-删除"><a href="#一、增加-和-删除" class="headerlink" title="一、增加 和 删除"></a>一、增加 和 删除</h4><p>创建节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(string) &#123;</span><br><span class="line">  const container &#x3D; document.createElement(&quot;template&quot;)</span><br><span class="line">   &#x2F;&#x2F;template可以包含任意节点</span><br><span class="line">  container.innerHTML &#x3D; string.trim()</span><br><span class="line">  return container.content.firstChild</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<p>改变位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在目标节点前面插入</span><br><span class="line">  before(newNode, node) &#123;</span><br><span class="line">    node.parentNode.insertBefore(newNode, node)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在目标节点后面插入，也就是在目标节点的下一个节点的前面插入</span><br><span class="line">  after(newNode, node) &#123;</span><br><span class="line">    node.parentNode.insertBefore(newNode, node.nextSibling)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>作为目标节点子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">append(parent, node) &#123;</span><br><span class="line">  parent.appendChild(node)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>作为目标节点父节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wrap(node, parent) &#123;</span><br><span class="line">  dom.before(parent, node)</span><br><span class="line">  dom.append(parent, node)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remove(node) &#123;</span><br><span class="line">  node.parentNode.removeChild(node)</span><br><span class="line">  return node</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>清空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">empty(parent) &#123;</span><br><span class="line">  let array &#x3D; []</span><br><span class="line">  let x &#x3D; parent.firstChild</span><br><span class="line">  while (x) &#123;</span><br><span class="line">  &#x2F;&#x2F;删除子节点会使children的长度马上变化，所以不能用for循环遍历</span><br><span class="line">    array.push(dom.remove(x))</span><br><span class="line">    x &#x3D; parent.firstChild</span><br><span class="line">  &#125;</span><br><span class="line">  return array</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="二、读写操作"><a href="#二、读写操作" class="headerlink" title="二、读写操作"></a>二、读写操作</h4><p>读写属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断参数数量，执行不同的操作</span><br><span class="line">  attr(node, name, value) &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">      node.setAttribute(name, value)</span><br><span class="line">    &#125; else if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">      return node.getAttribute(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>读写文本内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text(node, string) &#123;</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    if (&quot;innerText&quot; in node) &#123;    &#x2F;&#x2F;浏览器兼容</span><br><span class="line">      node.innerText &#x3D; string</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.textContent &#x3D; string</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (arguments.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    if (&quot;innerText&quot; in node) &#123;</span><br><span class="line">      return node.innerText</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return node.textContent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>读写 HTML 内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html(node, string) &#123;</span><br><span class="line">  if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    node.innerHTML &#x3D; string</span><br><span class="line">  &#125; else if (arguments.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return node.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>读写 style</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  style(node, name, value) &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">      node.style[name] &#x3D; value</span><br><span class="line">    &#125; else if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">      if (typeof name &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;</span><br><span class="line">        return node.style[name]</span><br><span class="line">      &#125; else if (name instanceof Object) &#123;</span><br><span class="line">        const object &#x3D; name</span><br><span class="line">        for (let key in object) &#123;</span><br><span class="line">          node.style[key] &#x3D; object[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F;用法</span><br><span class="line">dom.style(node,&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">dom.style(node,&quot;color&quot;)</span><br><span class="line">dom.style(node,&#123;color:&quot;red&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>class 增加和删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class: &#123;</span><br><span class="line">    add(node, className) &#123;</span><br><span class="line">      node.classList.add(className)</span><br><span class="line">    &#125;,</span><br><span class="line">    remove(node, className) &#123;</span><br><span class="line">      node.classList.remove(className)</span><br><span class="line">    &#125;,</span><br><span class="line">    has(node, className) &#123;</span><br><span class="line">      return node.classList.contains(className)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>添加、移出事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on(node, eventName, fn) &#123;</span><br><span class="line">  node.addEventListener(eventName, fn)</span><br><span class="line">&#125;,</span><br><span class="line">off(node, eventName, fn) &#123;</span><br><span class="line">  node.removeEventListener(eventName, fn)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="三、查找操作"><a href="#三、查找操作" class="headerlink" title="三、查找操作"></a>三、查找操作</h4><p>选择器查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find(selector, scope) &#123;</span><br><span class="line">    &#x2F;&#x2F;查找范围 全局或给定范围</span><br><span class="line">   return (scope || document).querySelectorAll(selector)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>获取父元素/子元素/兄弟元素/上一个元素/下一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent(node) &#123;</span><br><span class="line">  return node.parentNode</span><br><span class="line">&#125;,</span><br><span class="line">children(node) &#123;</span><br><span class="line">  return node.children</span><br><span class="line">&#125;,</span><br><span class="line">sibling(node) &#123;</span><br><span class="line">  &#x2F;&#x2F;获取父元素的子元素排除自己</span><br><span class="line">  return Array.from(node.parentNode.children).filter((n) &#x3D;&gt; n !&#x3D;&#x3D; node)</span><br><span class="line">&#125;,</span><br><span class="line">next(node) &#123;</span><br><span class="line">  let x &#x3D; node.nextSibling</span><br><span class="line">  &#x2F;&#x2F;如果节点type为3 文本，就找下一个</span><br><span class="line">  while (x &amp;&amp; x.nodeType &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">    x &#x3D; x.nextSibling</span><br><span class="line">  &#125;</span><br><span class="line">  return x</span><br><span class="line">&#125;,</span><br><span class="line">previous(node) &#123;</span><br><span class="line">  &#x2F;&#x2F;同上</span><br><span class="line">  let x &#x3D; node.previousSibling</span><br><span class="line">  while (x &amp;&amp; x.nodeType &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">    x &#x3D; x.previousSibling</span><br><span class="line">  &#125;</span><br><span class="line">  return x</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">each(nodes, fn) &#123;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    fn.call(null, nodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>获取下标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index(node) &#123;</span><br><span class="line">    let list &#x3D; dom.children(node.parentNode)</span><br><span class="line">    let i</span><br><span class="line">    for (i &#x3D; 0; i &lt; list.length; i++) &#123;</span><br><span class="line">      if (list[i] &#x3D;&#x3D;&#x3D; node) &#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>异步与Promise</title>
    <url>/2021/03/10/%E5%BC%82%E6%AD%A5%E5%92%8CPromise/</url>
    <content><![CDATA[<h3 id="一、异步与同步"><a href="#一、异步与同步" class="headerlink" title="一、异步与同步"></a>一、异步与同步</h3><p>同步:一定要当前任务执行完，才会执行下一个任务。</p>
 <a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fn1&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">  return &#39;结果&#39;</span><br><span class="line">&#125;</span><br><span class="line">const fn2&#x3D;()&#x3D;&gt;&#123;&#125;</span><br><span class="line">let x&#x3D;fn1()  &#x2F;&#x2F;拿到fn1的返回值之后才会执行下一句</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<p>异步：不等任务执行完，就执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1 &#x3D; function(callback)&#123;</span><br><span class="line">  const result &#x3D; setTimeout(function()&#123;</span><br><span class="line">    callback(&#39;结果&#39;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">fn1(function callback(x)&#123;</span><br><span class="line">  console.log(x)  &#x2F;&#x2F;别的代码执行完，再回来执行</span><br><span class="line">&#125;)</span><br><span class="line">fn2() &#x2F;&#x2F;先执行这一句</span><br></pre></td></tr></table></figure>
<h3 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h3><p>Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。</p>
<h4 id="1、-创建-Promise"><a href="#1、-创建-Promise" class="headerlink" title="1、 创建 Promise"></a>1、 创建 Promise</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  if()&#123;</span><br><span class="line">    resolve(someValue)</span><br><span class="line">    &#x2F;&#x2F; fulfilled 已兑现: 意味着操作成功完成。</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    rejected()</span><br><span class="line">    &#x2F;&#x2F;reject(&quot;failure reason&quot;) 已拒绝: 意味着操作失败</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数接受一个函数作为参数</li>
</ul>
<ul>
<li>调用构造函数得到实例 promise 的同时，作为参数的函数会立即执行</li>
<li>参数函数接受两个回调函数参数 resolve 和 reject</li>
</ul>
<ul>
<li>在参数函数被执行的过程中，如果在其内部调用 resolve，会将 promise 的状态变成 fulfilled，或者调用 reject，会将 promise 的状态变成 rejected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(()&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;  resolve，执行这里</span><br><span class="line">&#125;,()&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; reject 执行这里</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>待定状态（pending）的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个原因（错误）被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。</p>
<h4 id="2、Promise-的作用"><a href="#2、Promise-的作用" class="headerlink" title="2、Promise 的作用"></a>2、Promise 的作用</h4><ul>
<li>解决回调地狱的问题（避免了层层嵌套的回调函数）</li>
<li>语法非常简洁。Promise 对象提供了简洁的 API，使得控制异步操作更加容易</li>
</ul>
<h4 id="3、Promise-的使用"><a href="#3、Promise-的使用" class="headerlink" title="3、Promise 的使用"></a>3、Promise 的使用</h4><ul>
<li>new Promise：创建 Promise 实例</li>
<li>.then 和 .catch 和 .finally<ul>
<li><code>.then</code>:返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</li>
<li>返回一个 Promise，并且处理拒绝的情况。(相当于只有一个参数的.then)</li>
<li>finally() 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。<br>这避免了同样的语句需要在 then()和 catch()中各写一次的情况。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Promise.all/Promise.race/Promise.reject/Promise.resolve</p>
<ul>
<li><p>Promise.all() 方法接收一个 promise 的数组，并且只返回一个 Promise 实例，它的 resolve 回调会在所有的 Promise 的 resolve 都执行结束之后，才会调用，它的 reject 回调只要有任何一个 Promise 的 reject 被执行，就会被调用</p>
</li>
<li><p>Promise.race(),接受 Promise 数组，返回一个 promise，一旦某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
</li>
<li><p>Promise.reject(reason)返回一个带有拒绝原因的 Promise 对象。</p>
</li>
<li><p>Promise.resolve(value) 方法返回一个以给定值解析后的 Promise 对象,value 可以是带有.then 方法的对象，也可以是 Promise(将直接返回这个 Promise)</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise1&#x3D;Promise.resolve(1)</span><br><span class="line">const promise2&#x3D;Promise.resolve(promise1)</span><br><span class="line">promise1&#x3D;&#x3D;&#x3D;promise2 &#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<p>接受带有.then 方法的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出错误之后resolve</span><br><span class="line">let x &#x3D; &#123; then: function(resolve) &#123;</span><br><span class="line">  throw new Error(&quot;错误&quot;);</span><br><span class="line">  resolve(&quot;Resolving&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">let y &#x3D; Promise.resolve(x);</span><br><span class="line">y.then(function(v) &#123;</span><br><span class="line">    &#x2F;&#x2F;不会执行</span><br><span class="line">&#125;, function(e) &#123;</span><br><span class="line">  console.log(e);   &#x2F;&#x2F;打出错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抛出错误之前 resolve</span><br><span class="line">let m &#x3D; &#123; then: function(resolve) &#123;</span><br><span class="line">  resolve(&quot;完成&quot;);</span><br><span class="line">  throw new Error(&quot;错误&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">var n &#x3D; Promise.resolve(m);</span><br><span class="line">n.then(function(v) &#123;</span><br><span class="line">  console.log(v); &#x2F;&#x2F; 输出&quot;完成&quot;</span><br><span class="line">&#125;, function(e) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被调用</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4></li>
</ul>
</li>
</ul>
<p><a href="https://es6.ruanyifeng.com/#docs/promise">阮一峰 ECMAScript 6 入门</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2021/03/11/%E8%99%9A%E6%8B%9Fdom/</url>
    <content><![CDATA[<h2 id="一、虚拟-DOM"><a href="#一、虚拟-DOM" class="headerlink" title="一、虚拟 DOM"></a>一、虚拟 DOM</h2><h4 id="1、虚拟-DOM-是什么？"><a href="#1、虚拟-DOM-是什么？" class="headerlink" title="1、虚拟 DOM 是什么？"></a>1、虚拟 DOM 是什么？</h4><p>一个能代表 DOM 树的对象，通常含有标签名、标签上的属性，事件监听以及其他属性</p>
<h4 id="2、虚拟-DOM-的优点"><a href="#2、虚拟-DOM-的优点" class="headerlink" title="2、虚拟 DOM 的优点"></a>2、虚拟 DOM 的优点</h4><ol>
<li>减少 DOM 操作</li>
</ol>
<ul>
<li>虚拟 DOM 可以将多次 DOM 操作合并成一次操作。比如添加 1000 个节点，DOM 是一个一个操作，虚拟 DOM 可以减少 DOM 操作次数</li>
<li>虚拟 DOM 借助 DOM diff 可以省掉多余操作。比如添加 1000 个节点，只有 10 个是新增的。虚拟 DOM 可以减少操作范围</li>
</ul>
<ol start="2">
<li>跨平台</li>
</ol>
<ul>
<li>虚拟 DOM 是一个对象，不仅可以变成 DOM 还可以变成小程序，ios 应用，本质上是一个 JS 对象</li>
</ul>
<h4 id="3、虚拟-DOM-的缺点"><a href="#3、虚拟-DOM-的缺点" class="headerlink" title="3、虚拟 DOM 的缺点"></a>3、虚拟 DOM 的缺点</h4><p>需要额外的创建函数，比如<code>createElement</code>，或<code>h</code>,可以通过 JSX 和 XML 简化，但严重依赖打包工具</p>
<h2 id="二、DOM-diff"><a href="#二、DOM-diff" class="headerlink" title="二、DOM diff"></a>二、DOM diff</h2><p>DOM diff 是虚拟 DOM 的对比算法</p>
<h4 id="1、DOM-diff-的优点"><a href="#1、DOM-diff-的优点" class="headerlink" title="1、DOM diff 的优点"></a>1、DOM diff 的优点</h4><ul>
<li><p>diff 算法会帮助我们计算出虚拟 DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。</p>
</li>
<li><p>大概逻辑</p>
<p>Tree diff</p>
<ul>
<li>将新旧两棵树逐层对比，找出哪些节点需要更新</li>
<li>如果节点是组件就看 Component diff</li>
<li>如果节点是标签就看 Element diff</li>
</ul>
<p>Component diff</p>
<ul>
<li>如果节点是组件，就先看组件类型</li>
<li>类型不同直接替换（删除旧的）</li>
<li>类型相同则只更新属性</li>
<li>然后深入组件做 Tree diff（递归）</li>
</ul>
<p>Element diff</p>
<ul>
<li>如果节点是原生标签，则看标签名</li>
<li>标签名不同直接替换，相同则只更新属性</li>
<li>然后进入标签后代做 Tree diff（递归）</li>
</ul>
</li>
</ul>
<h4 id="2、DOM-diff-的问题"><a href="#2、DOM-diff-的问题" class="headerlink" title="2、DOM diff 的问题"></a>2、DOM diff 的问题</h4><ul>
<li>DOM diff 在同级对比时会出现 bug。由于计算机总是从上到下，从做左到右计算的，在同级别有多个节点，删除前面的节点时，会被 diff 算法认为是修改了前面的节点，删除了后面的节点，这就会导致渲染不符合预期。</li>
<li>解决方法是，在每一个节点增加一个唯一的 key 属性，用来标识节点。这也是 Vue 和 React 在使用循环时需要添加 key 属性的原因</li>
</ul>
]]></content>
      <tags>
        <tag>框架</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包和立即执行函数</title>
    <url>/2021/03/10/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>闭包</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域 CORS和JSON</title>
    <url>/2021/03/09/%E8%B7%A8%E5%9F%9F%20CORS%E5%92%8CJSONP/</url>
    <content><![CDATA[<h4 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h4><ol>
<li>同源定义：</li>
</ol>
<ul>
<li>源： window.Origin 或 location.origin 可以得到当前源</li>
<li>源=协议+域名+端口号</li>
<li>如果两个 url 协议、域名、端口号完全一致，那么这两个 url 就是同源的<a id="more"></a>
</li>
</ul>
<ol start="2">
<li>同源策略：</li>
</ol>
<ul>
<li>浏览器规定：如果 JS 运行在源 A，那么就只能获取源 A 的数据，不允许获取源 B 的数据，即不允许跨源</li>
<li>目的：保护隐私</li>
<li>主要原因：无法区分发送者，如果没有同源策略，任何网站都可以访问别的网站数据(检查 referer)</li>
<li>同源策略：不同源的页面中间，不允许互相访问数据</li>
</ul>
<ul>
<li>同源策略限制访问数据，引用 css、JS 和图片的时候，其实并不知道其内容，只是在引用</li>
</ul>
<h4 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h4><p>浏览器有同源策略限制，不允许一个源里的文档访问另一个源里资源。而跨域就是为了解决同源策略限制。</p>
<ul>
<li><p>CORS：<br>跨源资源共享，使用附加的 HTTP 头来告诉浏览器，准许运行在一个源上的 Web 应用访问位于另一不同源选定的资源。使用<strong>Access-Control-Allow-Origin</strong>响应头可以指定一个可以访问资源的 URI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;friends.json&quot;) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;json;charset&#x3D;utf-8&quot;)</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;crystal.com:9999&quot;)</span><br><span class="line">    response.write(fs.readFileSync(&quot;public&#x2F;friends.json&quot;))</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JSONP ：在无法使用 CORS 跨域的情况下，请求 JS 文件，这个 JS 文件会执行一个回调，回调里面包含数据。可以兼容 IE 浏览器实现跨域，但只能发 get 请求，并且无法读取精确的状态码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jsonp(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">     const random &#x3D; &quot;crystalJSONPCallbackName&quot; + Math.random()</span><br><span class="line">     window[random] &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">       resolve(data)</span><br><span class="line">     &#125;</span><br><span class="line">     const script &#x3D; document.createElement(&quot;script&quot;)</span><br><span class="line">     script.src &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;random&#125;&#96;</span><br><span class="line">     script.onload &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F;无法获取状态码，只能知道成功或者失败</span><br><span class="line">       script.remove()</span><br><span class="line">     &#125;</span><br><span class="line">     script.onerror &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">       reject()</span><br><span class="line">     &#125;</span><br><span class="line">     document.body.appendChild(script)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> jsonp(&quot;http:&#x2F;&#x2F;qq.com:8888&#x2F;friends.js&quot;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">   console.log(data)</span><br><span class="line"> &#125;)</span><br><span class="line"> script.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">   console.log(window.xxx)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (path &#x3D;&#x3D;&#x3D; &quot;&#x2F;friends.js&quot;) &#123;</span><br><span class="line">  if (request.headers[&quot;referer&quot;].indexOf(&quot;http:&#x2F;&#x2F;crystal.com:9999&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    response.statusCode &#x3D; 200</span><br><span class="line">    response.setHeader(&quot;Content-Type&quot;, &quot;text&#x2F;javascript;charset&#x3D;utf-8&quot;)</span><br><span class="line">    const string &#x3D; &#96;window[&quot;&#123;&#123;xxx&#125;&#125;&quot;](&#123;&#123;data&#125;&#125;)&#96;</span><br><span class="line">    const data &#x3D; fs.readFileSync(&quot;public&#x2F;friends.json&quot;).toString()</span><br><span class="line">    const string2 &#x3D; string</span><br><span class="line">      .replace(&quot;&#123;&#123;data&#125;&#125;&quot;, data)</span><br><span class="line">      .replace(&quot;&#123;&#123;xxx&#125;&#125;&quot;, query.callback)     &#x2F;&#x2F;上面的random</span><br><span class="line">    response.write(string2)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包和立即执行函数</title>
    <url>/2021/03/09/%E9%97%AD%E5%8C%85%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><pre><code>[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 的解释：
一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包</code></pre>
<h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><pre><code>1. 让外部访问函数内部变量成为可能；(隐藏变量)

2. 局部变量会常驻在内存中；

3. 可以避免使用全局变量，防止全局变量污染；</code></pre>
 <a id="more"></a>

<h4 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h4><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">let a&#x3D;1;</span><br><span class="line">function b()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">    a+&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line">const fn2&#x3D;fn1()</span><br><span class="line">fn2()   &#x2F;&#x2F;1</span><br><span class="line">fn2()   &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>
这就是一个最简单的闭包，fn2 可以获取到函数内部的变量 a</code></pre>
<h3 id="二、立即调用函数表达式（IIFE）"><a href="#二、立即调用函数表达式（IIFE）" class="headerlink" title="二、立即调用函数表达式（IIFE）"></a>二、立即调用函数表达式（IIFE）</h3><ol>
<li>在定义时就直接执行的函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    let x&#x3D;1;</span><br><span class="line">    return x</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li>可以将立即执行函数分配给一个变量，变量将得到函数的返回值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let a&#x3D;(function () &#123;</span><br><span class="line">    let x&#x3D;1;</span><br><span class="line">    return x</span><br><span class="line">&#125;)();</span><br><span class="line"> a &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<strong>作用</strong>：由于立即执行函数内部变量无法访问，立即执行函数可以避免变量污染。</li>
</ol>
<h3 id="一个经典的面试题"><a href="#一个经典的面试题" class="headerlink" title="一个经典的面试题"></a>一个经典的面试题</h3><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;&#x2F;&#x2F;输出 5个5</span><br></pre></td></tr></table></figure></code></pre>
<p>可以使用闭包和立即执行函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 依次打出0~4</span><br></pre></td></tr></table></figure>
<p>或者把 var 改为 let</p>
<p>var 声明的 i 相当于是在全局作用域，在 for 循环结束之后才会执行，因此打出 5 个 5</p>
<p>而使用 let，会在每次执行 for 循环的时候重新创建一个变量 i，每次循环是一个新的作用域，因此不会打出 5 个 5</p>
]]></content>
      <tags>
        <tag>闭包</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基本用法</title>
    <url>/2021/03/12/%E9%97%AD%E5%8C%85%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%20copy/</url>
    <content><![CDATA[<h3 id="一、createElement-和-JSX"><a href="#一、createElement-和-JSX" class="headerlink" title="一、createElement 和 JSX"></a>一、createElement 和 JSX</h3><ol>
<li>createElement</li>
</ol>
<p>创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 ‘div’ 或 ‘span’），也可以是 React 组件 类型 （class 组件或函数组件）,代码编写复杂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">  &#39;h1&#39;,</span><br><span class="line">  &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">  &#39;Hello, world!&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>JSX<br>下面代码会被编译为和上面相同的代码，完全等价</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">&lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">&lt;&#x2F;h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>在 JSX 中给元素添加类, 需要使用 className 代替 class</li>
<li>JSX 中可以直接使用 {} 中间写 JS 代码<a id="more"></a>

</li>
</ul>
</li>
</ol>
<h3 id="二、class-组件和生命周期钩子"><a href="#二、class-组件和生命周期钩子" class="headerlink" title="二、class 组件和生命周期钩子"></a>二、class 组件和生命周期钩子</h3><p>1、 class 组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);   &#x2F;&#x2F;必须用super调用父类的constructor</span><br><span class="line">    this.state &#x3D; &#123;n: 1&#125;;</span><br><span class="line">&#125;</span><br><span class="line">add()&#123;this.setSTate((state)&#x3D;&gt;    &#x2F;&#x2F;使用函数</span><br><span class="line">     return &#123;n:this.state.n+1&#125;)&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;this.state.n&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt;this.add()&#125;&gt;+1&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、 props 和 state</p>
<ul>
<li><p>props</p>
<ul>
<li>给组件传递数据，一般用在父子组件之间</li>
<li>React 把传递给组件的属性转化为一个对象并交给 props</li>
<li>props 是只读的，无法给 props 添加或修改属性</li>
<li>props.children：获取组件的内容</li>
</ul>
</li>
<li><p>state</p>
<ul>
<li>用来给组件提供组件内部使用的数据</li>
<li>只有通过 class 创建的组件才有，函数组件使用 useState</li>
<li>setState 是异步的，改变之后马上取取不到最新的值</li>
<li>setState 会自动合并第一层属性，useState 不会</li>
</ul>
</li>
</ul>
<p>3、生命周期钩子</p>
<ol>
<li><p>constructor</p>
<ul>
<li>初始化 props、state</li>
<li>此时不能调用 setState</li>
<li>bind this</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;     &#x2F;&#x2F;如果只是初始化props 可以省略</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;n: 1&#125;;</span><br><span class="line">    this.onClick&#x3D;this.onClick.bind(this)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等价于 写在 constructor外面</span><br><span class="line">onClick&#x3D;()&#x3D;&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>shouldComponentUpdate</p>
</li>
</ol>
<ul>
<li>返回 false 阻止 UI 更新</li>
<li>返回 true 不阻止</li>
<li>作用：允许手动判断是否需要更新组件，避免不必要的更新</li>
<li>如果返回值为 false，那么，后续 render()方法不会被调用</li>
<li>可以使用 React.PureComponent 代替 React.Component,两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。<a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent">官方文档</a></li>
</ul>
<ol start="3">
<li>render</li>
</ol>
<ul>
<li>展示视图</li>
<li>只能有一个根元素</li>
<li>多个根元素可以使用&lt;React.Fragment&gt;简写为 &lt;&gt;&lt;/&gt;</li>
<li>函数能够执行多次，只要组件的属性或状态改变了，这个方法就会重新执行</li>
</ul>
<ol start="4">
<li>componentDidMount</li>
</ol>
<ul>
<li>组件已经挂载到页面中</li>
<li>可以进行 DOM 操作，比如获取 DOM 元素的宽高属性</li>
<li>可以<strong>发送请求</strong>获取数据（<strong>官方推荐</strong>）</li>
</ul>
<ol start="5">
<li>componentDidUpdate</li>
</ol>
<ul>
<li><p>组件已经更新</p>
</li>
<li><p>不能修改状态 否则会循环渲染（除非条件判断）</p>
</li>
<li><p>首次渲染不会执行此方法</p>
</li>
<li><p>shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。</p>
</li>
<li><p>参数：旧的属性和状态对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li>componentWillUnmount()</li>
</ol>
<ul>
<li>组件卸载,组件一辈子只能执行一次</li>
<li>执行清理工作，清除定时器等</li>
</ul>
<h3 id="三、函数组件和-hooks"><a href="#三、函数组件和-hooks" class="headerlink" title="三、函数组件和 hooks"></a>三、函数组件和 hooks</h3><p>1、函数组件</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Demo(props) &#123;</span><br><span class="line">const [n,setN]&#x3D;React.useState(0)</span><br><span class="line">return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>2、hooks</p>
<ul>
<li><p>useState</p>
<ul>
<li>使用状态</li>
<li>不可局部更新，如果 state 是一个对象，并不会合并属性，可以使用…操作符</li>
<li>对象要改变地址，React 才认为数据改变了</li>
<li>初始化和 set 的时候可以使用函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [n,setN]&#x3D;React.useState(()&#x3D;&gt;&#123;return initialState&#125;))</span><br><span class="line"></span><br><span class="line">setN(x&#x3D;&gt;x+1)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>useReducer</p>
<p>useState 替代方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;      &#x2F;&#x2F;创建初始值</span><br><span class="line">function reducer(state, action) &#123;     &#x2F;&#x2F;创建所有操作</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">      case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">      case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">      default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> function Counter() &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);    &#x2F;&#x2F;传给useReducer，获取读写操作</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">       &#x2F;&#x2F;调用对应操作</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>useContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const X&#x3D;React.createContext(null)     &#x2F;&#x2F;创建上下文</span><br><span class="line">function App()&#123;</span><br><span class="line">    const [n,setN]&#x3D;useState(0)</span><br><span class="line">    return (</span><br><span class="line">        &lt;X.Provider value&#x3D;&#123;&#123;n,setN&#125;&#125;&gt; &#x2F;&#x2F;划定区域 绑定数据</span><br><span class="line">          &lt;Demo1&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;X.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function Demo1()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Demo2&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">function Demo2()&#123;</span><br><span class="line">    const &#123;n,setN&#125;&#x3D;useContext(X)     &#x2F;&#x2F;拿到数据</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;n&#125;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;()&#x3D;&gt;setN(x&#x3D;&gt;x+1)&#125;&gt;+1&lt;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>*使用 useReducer 和 useContext 代替 Redux**<br><a href="https://codesandbox.io/s/interesting-volhard-lfxpm">代码</a></p>
</li>
</ul>
<ul>
<li><p>useEffect</p>
<p>在函数组件中执行副作用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;,[])    &#x2F;&#x2F;只在第一次渲染执行 相当于componentDidMount</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;,[x])    &#x2F;&#x2F;在数组中依赖变化时执行</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;&#125;)</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    return ()&#x3D;&gt;&#123;&#125;  &#x2F;&#x2F; 在组件卸载时执行，清除计时器之类的操作</span><br><span class="line">&#125;)      &#x2F;&#x2F;每次渲染都执行</span><br></pre></td></tr></table></figure>
<p>useLayoutEffect:它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</p>
</li>
</ul>
<ul>
<li><p>useMemo、React.memo、useCallback</p>
<ol>
<li>React.memo：组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用,props 不变就不会重新渲染，<strong>如果 prop 是一个复杂对象，可以使用 useMemo</strong><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">文档</a></li>
<li>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。类似 Vue 的 computed</li>
<li>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</li>
</ol>
</li>
<li><p>useRef</p>
<ul>
<li>返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</li>
<li>React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。<strong>让函数组件在接受 props 之外，再接受一个 ref</strong><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">文档</a></li>
<li>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle">文档</a></li>
</ul>
</li>
<li><p>自定义 hook</p>
<p>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。<a href="https://codesandbox.io/s/recursing-darkness-zuo4b">例子</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>React 基本用法</title>
    <url>/2021/03/12/class/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.n&#x3D;()&#123;&#125;   &#x2F;&#x2F;方法在对象上</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">  n&#x3D;()&#x3D;&gt;&#123;&#125;  &#x2F;&#x2F;new的时候也会出现在对象上</span><br><span class="line">  n()&#123;&#125; &#x2F;&#x2F;new的时候会出现在原型上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
